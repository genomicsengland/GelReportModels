"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GEL protocol classes, please run the script
on the appropriate schema version.
"""
from protocols.protocol import ProtocolElement
from protocols.protocol import SearchRequest
from protocols.protocol import SearchResponse
from protocols.protocol import avro_parse

import avro.schema

version = '3.0.0'


class Call(ProtocolElement):
    """
    A `Call` represents the determination of genotype with respect to
    a particular `Variant`.  It may include associated information
    such as quality and phasing. For example, a call might assign a
    probability of 0.32 to the occurrence of a SNP named rs1234 in a
    call set with the name NA12345.
    """
    _schemaSource = """
{"type": "record", "name": "Call", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name":
"callSetName", "type": ["null", "string"], "doc": "", "default": null}, {"name": "callSetId",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "genotype", "type": {"type":
"array", "items": "int"}, "doc": "", "default": []}, {"name": "phaseset", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "genotypeLikelihood", "type": {"type": "array",
"items": "double"}, "doc": "", "default": []}, {"name": "info", "type": {"type": "map", "values":
{"type": "array", "items": "string"}}, "doc": "", "default": {}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetId', 'callSetName', 'genotype', 'genotypeLikelihood',
        'info', 'phaseset'
    ]

    def __init__(self, **kwargs):
        self.callSetId = kwargs.get(
            'callSetId', None)
        self.callSetName = kwargs.get(
            'callSetName', None)
        self.genotype = kwargs.get(
            'genotype', [])
        self.genotypeLikelihood = kwargs.get(
            'genotypeLikelihood', [])
        self.info = kwargs.get(
            'info', {})
        self.phaseset = kwargs.get(
            'phaseset', None)


class CallSet(ProtocolElement):
    """
    A `CallSet` is a collection of variant calls for a particular
    sample. It belongs to a `VariantSet`. This is equivalent to one
    column in VCF.
    """
    _schemaSource = """
{"type": "record", "name": "CallSet", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "name", "type": ["null", "string"], "doc":
"", "default": null}, {"name": "sampleId", "type": ["null", "string"], "doc": ""}, {"name":
"variantSetIds", "type": {"type": "array", "items": "string"}, "doc": "", "default": []}, {"name":
"created", "type": ["null", "long"], "doc": "", "default": null}, {"name": "updated", "type":
["null", "long"], "doc": "", "default": null}, {"name": "info", "type": {"type": "map", "values":
{"type": "array", "items": "string"}}, "doc": "", "default": {}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "sampleId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'id', 'info', 'name', 'sampleId', 'updated',
        'variantSetIds'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        self.id = kwargs.get(
            'id', None)
        self.info = kwargs.get(
            'info', {})
        self.name = kwargs.get(
            'name', None)
        self.sampleId = kwargs.get(
            'sampleId', None)
        self.updated = kwargs.get(
            'updated', None)
        self.variantSetIds = kwargs.get(
            'variantSetIds', [])


class CigarOperation(object):
    """
    An enum for the different types of CIGAR alignment operations that
    exist. Used wherever CIGAR alignments are used. The different
    enumerated values have the following usage:  * `ALIGNMENT_MATCH`:
    An alignment match indicates that a sequence can be   aligned to
    the reference without evidence of an INDEL. Unlike the
    `SEQUENCE_MATCH` and `SEQUENCE_MISMATCH` operators, the
    `ALIGNMENT_MATCH`   operator does not indicate whether the
    reference and read sequences are an   exact match. This operator
    is equivalent to SAM's `M`. * `INSERT`: The insert operator
    indicates that the read contains evidence of   bases being
    inserted into the reference. This operator is equivalent to
    SAM's `I`. * `DELETE`: The delete operator indicates that the read
    contains evidence of   bases being deleted from the reference.
    This operator is equivalent to   SAM's `D`. * `SKIP`: The skip
    operator indicates that this read skips a long segment of   the
    reference, but the bases have not been deleted. This operator is
    commonly used when working with RNA-seq data, where reads may skip
    long   segments of the reference between exons. This operator is
    equivalent to   SAM's 'N'. * `CLIP_SOFT`: The soft clip operator
    indicates that bases at the start/end   of a read have not been
    considered during alignment. This may occur if the   majority of a
    read maps, except for low quality bases at the start/end of   a
    read. This operator is equivalent to SAM's 'S'. Bases that are
    soft clipped   will still be stored in the read. * `CLIP_HARD`:
    The hard clip operator indicates that bases at the start/end of
    a read have been omitted from this alignment. This may occur if
    this linear   alignment is part of a chimeric alignment, or if the
    read has been trimmed   (e.g., during error correction, or to trim
    poly-A tails for RNA-seq). This   operator is equivalent to SAM's
    'H'. * `PAD`: The pad operator indicates that there is padding in
    an alignment.   This operator is equivalent to SAM's 'P'. *
    `SEQUENCE_MATCH`: This operator indicates that this portion of the
    aligned   sequence exactly matches the reference (e.g., all bases
    are equal to the   reference bases). This operator is equivalent
    to SAM's '='. * `SEQUENCE_MISMATCH`: This operator indicates that
    this portion of the   aligned sequence is an alignment match to
    the reference, but a sequence   mismatch (e.g., the bases are not
    equal to the reference). This can   indicate a SNP or a read
    error. This operator is equivalent to SAM's 'X'.
    """
    ALIGNMENT_MATCH = "ALIGNMENT_MATCH"
    INSERT = "INSERT"
    DELETE = "DELETE"
    SKIP = "SKIP"
    CLIP_SOFT = "CLIP_SOFT"
    CLIP_HARD = "CLIP_HARD"
    PAD = "PAD"
    SEQUENCE_MATCH = "SEQUENCE_MATCH"
    SEQUENCE_MISMATCH = "SEQUENCE_MISMATCH"

    def __hash__(self):
        return str(self).__hash__()


class CigarUnit(ProtocolElement):
    """
    A structure for an instance of a CIGAR operation.
    """
    _schemaSource = """
{"type": "record", "name": "CigarUnit", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "operation", "type": {"type": "enum", "name": "CigarOperation", "doc": "", "symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"]}, "doc": ""}, {"name": "operationLength", "type": "long", "doc": ""}, {"name":
"referenceSequence", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "operation",
        "operationLength",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'operation', 'operationLength', 'referenceSequence'
    ]

    def __init__(self, **kwargs):
        self.operation = kwargs.get(
            'operation', None)
        self.operationLength = kwargs.get(
            'operationLength', None)
        self.referenceSequence = kwargs.get(
            'referenceSequence', None)


class Dataset(ProtocolElement):
    """
    Represents a group of contextually related data objects of (e.g.
    all Individuals, Samples,  Experiments associated with a
    particular feature; or e.g. a trio in genetic diagnostics.). This
    concept may be expanded in the future (ontology for describing the
    type of dataset ...). TODO: Determination of scope, structure,
    specific attributes, e.g. limiting to single  record type - see
    http://purl.obolibrary.org/obo/IAO_0000100 - and providing
    alternative mechanism  for heterogeneous data with external
    contextualization, e.g. all records of different  types associated
    with a clinical study.
    """
    _schemaSource = """
{"type": "record", "name": "Dataset", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "description", "type": ["null", "string"],
"doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        self.id = kwargs.get(
            'id', None)


class Experiment(ProtocolElement):
    """
    An experimental preparation of a `Sample`.
    """
    _schemaSource = """
{"type": "record", "name": "Experiment", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "name", "type": ["null", "string"], "doc":
"", "default": null}, {"name": "description", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "recordCreateTime", "type": "string", "doc": ""}, {"name": "recordUpdateTime",
"type": "string", "doc": ""}, {"name": "runTime", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "molecule", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"strategy", "type": ["null", "string"], "doc": "", "default": null}, {"name": "selection", "type":
["null", "string"], "doc": "", "default": null}, {"name": "library", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "libraryLayout", "type": ["null", "string"], "doc": "",
"default": null}, {"name": "instrumentModel", "type": ["null", "string"], "doc": ""}, {"name":
"instrumentDataFile", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"sequencingCenter", "type": ["null", "string"], "doc": ""}, {"name": "platformUnit", "type":
["null", "string"], "doc": "", "default": null}, {"name": "info", "type": {"type": "map", "values":
{"type": "array", "items": "string"}}, "doc": "", "default": {}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "instrumentModel",
        "recordCreateTime",
        "recordUpdateTime",
        "sequencingCenter",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'instrumentDataFile',
        'instrumentModel', 'library', 'libraryLayout', 'molecule',
        'name', 'platformUnit', 'recordCreateTime',
        'recordUpdateTime', 'runTime', 'selection',
        'sequencingCenter', 'strategy'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        self.id = kwargs.get(
            'id', None)
        self.info = kwargs.get(
            'info', {})
        self.instrumentDataFile = kwargs.get(
            'instrumentDataFile', None)
        self.instrumentModel = kwargs.get(
            'instrumentModel', None)
        self.library = kwargs.get(
            'library', None)
        self.libraryLayout = kwargs.get(
            'libraryLayout', None)
        self.molecule = kwargs.get(
            'molecule', None)
        self.name = kwargs.get(
            'name', None)
        self.platformUnit = kwargs.get(
            'platformUnit', None)
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        self.runTime = kwargs.get(
            'runTime', None)
        self.selection = kwargs.get(
            'selection', None)
        self.sequencingCenter = kwargs.get(
            'sequencingCenter', None)
        self.strategy = kwargs.get(
            'strategy', None)


class ExternalIdentifier(ProtocolElement):
    """
    Identifier from a public database
    """
    _schemaSource = """
{"type": "record", "name": "ExternalIdentifier", "namespace": "org.ga4gh.models", "doc": "",
"fields": [{"name": "database", "type": "string", "doc": ""}, {"name": "identifier", "type":
"string", "doc": ""}, {"name": "version", "type": "string", "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "database",
        "identifier",
        "version",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'database', 'identifier', 'version'
    ]

    def __init__(self, **kwargs):
        self.database = kwargs.get(
            'database', None)
        self.identifier = kwargs.get(
            'identifier', None)
        self.version = kwargs.get(
            'version', None)


class Fragment(ProtocolElement):
    """
    A fragment represents a contiguous stretch of a DNA or RNA
    molecule. Reads can be associated with a fragment to specify they
    derive from the same molecule.
    """
    _schemaSource = """
{"type": "record", "name": "Fragment", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)


class GAException(ProtocolElement):
    """
    A general exception type.
    """
    _schemaSource = """
{"type": "error", "name": "GAException", "namespace": "org.ga4gh.methods", "doc": "", "fields":
[{"name": "message", "type": "string", "doc": ""}, {"name": "errorCode", "type": "int", "doc": "",
"default": -1}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "message",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'errorCode', 'message'
    ]

    def __init__(self, **kwargs):
        self.errorCode = kwargs.get(
            'errorCode', -1)
        self.message = kwargs.get(
            'message', None)


class LinearAlignment(ProtocolElement):
    """
    A linear alignment can be represented by one CIGAR string.
    """
    _schemaSource = """
{"type": "record", "name": "LinearAlignment", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "position", "type": {"type": "record", "name": "Position", "doc": "", "fields": [{"name":
"referenceName", "type": "string", "doc": ""}, {"name": "position", "type": "long", "doc": ""},
{"name": "strand", "type": {"type": "enum", "name": "Strand", "doc": "", "symbols": ["NEG_STRAND",
"POS_STRAND"]}, "doc": ""}]}, "doc": ""}, {"name": "mappingQuality", "type": ["null", "int"], "doc":
"", "default": null}, {"name": "cigar", "type": {"type": "array", "items": {"type": "record",
"name": "CigarUnit", "doc": "", "fields": [{"name": "operation", "type": {"type": "enum", "name":
"CigarOperation", "doc": "", "symbols": ["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"]}, "doc": ""}, {"name": "operationLength",
"type": "long", "doc": ""}, {"name": "referenceSequence", "type": ["null", "string"], "doc": "",
"default": null}]}}, "doc": "", "default": []}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "position",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'position'
    ]

    def __init__(self, **kwargs):
        self.cigar = kwargs.get(
            'cigar', [])
        self.mappingQuality = kwargs.get(
            'mappingQuality', None)
        self.position = kwargs.get(
            'position', Position())


class ListReferenceBasesRequest(ProtocolElement):
    """
    The query parameters for a request to `GET
    /references/{id}/bases`, for example:  `GET
    /references/{id}/bases?start=100&end=200`
    """
    _schemaSource = """
{"type": "record", "name": "ListReferenceBasesRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "start", "type": "long", "doc": "", "default": 0}, {"name": "end", "type":
["null", "long"], "doc": "", "default": null}, {"name": "pageToken", "type": ["null", "string"],
"doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageToken', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        self.pageToken = kwargs.get(
            'pageToken', None)
        self.start = kwargs.get(
            'start', 0)


class ListReferenceBasesResponse(ProtocolElement):
    """
    The response from `GET /references/{id}/bases` expressed as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "ListReferenceBasesResponse", "namespace": "org.ga4gh.methods", "doc":
"", "fields": [{"name": "offset", "type": "long", "doc": "", "default": 0}, {"name": "sequence",
"type": "string", "doc": ""}, {"name": "nextPageToken", "type": ["null", "string"], "doc": "",
"default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "sequence",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'offset', 'sequence'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        self.offset = kwargs.get(
            'offset', 0)
        self.sequence = kwargs.get(
            'sequence', None)


class Position(ProtocolElement):
    """
    A `Position` is an unoriented base in some `Reference`. A
    `Position` is represented by a `Reference` name, and a base number
    on that `Reference` (0-based).
    """
    _schemaSource = """
{"type": "record", "name": "Position", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "referenceName", "type": "string", "doc": ""}, {"name": "position", "type": "long", "doc":
""}, {"name": "strand", "type": {"type": "enum", "name": "Strand", "doc": "", "symbols":
["NEG_STRAND", "POS_STRAND"]}, "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "position",
        "referenceName",
        "strand",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'position', 'referenceName', 'strand'
    ]

    def __init__(self, **kwargs):
        self.position = kwargs.get(
            'position', None)
        self.referenceName = kwargs.get(
            'referenceName', None)
        self.strand = kwargs.get(
            'strand', None)


class Program(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Program", "namespace": "org.ga4gh.models", "fields": [{"name":
"commandLine", "type": ["null", "string"], "doc": "", "default": null}, {"name": "id", "type":
["null", "string"], "doc": "", "default": null}, {"name": "name", "type": ["null", "string"], "doc":
"", "default": null}, {"name": "prevProgramId", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "version", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'commandLine', 'id', 'name', 'prevProgramId', 'version'
    ]

    def __init__(self, **kwargs):
        self.commandLine = kwargs.get(
            'commandLine', None)
        self.id = kwargs.get(
            'id', None)
        self.name = kwargs.get(
            'name', None)
        self.prevProgramId = kwargs.get(
            'prevProgramId', None)
        self.version = kwargs.get(
            'version', None)


class ReadAlignment(ProtocolElement):
    """
    Each read alignment describes an alignment with additional
    information about the fragment and the read. A read alignment
    object is equivalent to a line in a SAM file.
    """
    _schemaSource = """
{"type": "record", "name": "ReadAlignment", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": ["null", "string"], "doc": ""}, {"name": "readGroupId", "type": "string",
"doc": ""}, {"name": "fragmentId", "type": "string", "doc": ""}, {"name": "fragmentName", "type":
"string", "doc": ""}, {"name": "properPlacement", "type": ["null", "boolean"], "doc": "", "default":
null}, {"name": "duplicateFragment", "type": ["null", "boolean"], "doc": "", "default": null},
{"name": "numberReads", "type": ["null", "int"], "doc": "", "default": null}, {"name":
"fragmentLength", "type": ["null", "int"], "doc": "", "default": null}, {"name": "readNumber",
"type": ["null", "int"], "doc": "", "default": null}, {"name": "failedVendorQualityChecks", "type":
["null", "boolean"], "doc": "", "default": null}, {"name": "alignment", "type": ["null", {"type":
"record", "name": "LinearAlignment", "doc": "", "fields": [{"name": "position", "type": {"type":
"record", "name": "Position", "doc": "", "fields": [{"name": "referenceName", "type": "string",
"doc": ""}, {"name": "position", "type": "long", "doc": ""}, {"name": "strand", "type": {"type":
"enum", "name": "Strand", "doc": "", "symbols": ["NEG_STRAND", "POS_STRAND"]}, "doc": ""}]}, "doc":
""}, {"name": "mappingQuality", "type": ["null", "int"], "doc": "", "default": null}, {"name":
"cigar", "type": {"type": "array", "items": {"type": "record", "name": "CigarUnit", "doc": "",
"fields": [{"name": "operation", "type": {"type": "enum", "name": "CigarOperation", "doc": "",
"symbols": ["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"]}, "doc": ""}, {"name": "operationLength", "type": "long",
"doc": ""}, {"name": "referenceSequence", "type": ["null", "string"], "doc": "", "default":
null}]}}, "doc": "", "default": []}]}], "doc": "", "default": null}, {"name": "secondaryAlignment",
"type": ["null", "boolean"], "doc": "", "default": null}, {"name": "supplementaryAlignment", "type":
["null", "boolean"], "doc": "", "default": null}, {"name": "alignedSequence", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "alignedQuality", "type": {"type": "array",
"items": "int"}, "doc": "", "default": []}, {"name": "nextMatePosition", "type": ["null",
"Position"], "doc": "", "default": null}, {"name": "info", "type": {"type": "map", "values":
{"type": "array", "items": "string"}}, "doc": "", "default": {}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "fragmentId",
        "fragmentName",
        "id",
        "readGroupId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedQuality', 'alignedSequence', 'alignment',
        'duplicateFragment', 'failedVendorQualityChecks',
        'fragmentId', 'fragmentLength', 'fragmentName', 'id', 'info',
        'nextMatePosition', 'numberReads', 'properPlacement',
        'readGroupId', 'readNumber', 'secondaryAlignment',
        'supplementaryAlignment'
    ]

    def __init__(self, **kwargs):
        self.alignedQuality = kwargs.get(
            'alignedQuality', [])
        self.alignedSequence = kwargs.get(
            'alignedSequence', None)
        self.alignment = kwargs.get(
            'alignment', None)
        self.duplicateFragment = kwargs.get(
            'duplicateFragment', None)
        self.failedVendorQualityChecks = kwargs.get(
            'failedVendorQualityChecks', None)
        self.fragmentId = kwargs.get(
            'fragmentId', None)
        self.fragmentLength = kwargs.get(
            'fragmentLength', None)
        self.fragmentName = kwargs.get(
            'fragmentName', None)
        self.id = kwargs.get(
            'id', None)
        self.info = kwargs.get(
            'info', {})
        self.nextMatePosition = kwargs.get(
            'nextMatePosition', None)
        self.numberReads = kwargs.get(
            'numberReads', None)
        self.properPlacement = kwargs.get(
            'properPlacement', None)
        self.readGroupId = kwargs.get(
            'readGroupId', None)
        self.readNumber = kwargs.get(
            'readNumber', None)
        self.secondaryAlignment = kwargs.get(
            'secondaryAlignment', None)
        self.supplementaryAlignment = kwargs.get(
            'supplementaryAlignment', None)


class ReadGroup(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ReadGroup", "namespace": "org.ga4gh.models", "fields": [{"name": "id",
"type": "string", "doc": ""}, {"name": "datasetId", "type": ["null", "string"], "doc": "",
"default": null}, {"name": "name", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"description", "type": ["null", "string"], "doc": "", "default": null}, {"name": "sampleId", "type":
["null", "string"], "doc": ""}, {"name": "experiment", "type": ["null", {"type": "record", "name":
"Experiment", "doc": "", "fields": [{"name": "id", "type": "string", "doc": ""}, {"name": "name",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "description", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "recordCreateTime", "type": "string", "doc": ""},
{"name": "recordUpdateTime", "type": "string", "doc": ""}, {"name": "runTime", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "molecule", "type": ["null", "string"], "doc": "",
"default": null}, {"name": "strategy", "type": ["null", "string"], "doc": "", "default": null},
{"name": "selection", "type": ["null", "string"], "doc": "", "default": null}, {"name": "library",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "libraryLayout", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "instrumentModel", "type": ["null", "string"],
"doc": ""}, {"name": "instrumentDataFile", "type": ["null", "string"], "doc": "", "default": null},
{"name": "sequencingCenter", "type": ["null", "string"], "doc": ""}, {"name": "platformUnit",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "info", "type": {"type": "map",
"values": {"type": "array", "items": "string"}}, "doc": "", "default": {}}]}], "doc": ""}, {"name":
"predictedInsertSize", "type": ["null", "int"], "doc": "", "default": null}, {"name": "created",
"type": ["null", "long"], "doc": "", "default": null}, {"name": "updated", "type": ["null", "long"],
"doc": "", "default": null}, {"name": "stats", "type": ["null", {"type": "record", "name":
"ReadStats", "fields": [{"name": "alignedReadCount", "type": ["null", "long"], "doc": "", "default":
null}, {"name": "unalignedReadCount", "type": ["null", "long"], "doc": "", "default": null},
{"name": "baseCount", "type": ["null", "long"], "doc": "", "default": null}]}], "doc": "",
"default": null}, {"name": "programs", "type": {"type": "array", "items": {"type": "record", "name":
"Program", "fields": [{"name": "commandLine", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "id", "type": ["null", "string"], "doc": "", "default": null}, {"name": "name",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "prevProgramId", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "version", "type": ["null", "string"], "doc": "",
"default": null}]}}, "doc": "", "default": []}, {"name": "referenceSetId", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "info", "type": {"type": "map", "values": {"type":
"array", "items": "string"}}, "doc": "", "default": {}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "experiment",
        "id",
        "sampleId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'datasetId', 'description', 'experiment', 'id',
        'info', 'name', 'predictedInsertSize', 'programs',
        'referenceSetId', 'sampleId', 'stats', 'updated'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        self.datasetId = kwargs.get(
            'datasetId', None)
        self.description = kwargs.get(
            'description', None)
        self.experiment = kwargs.get(
            'experiment', None)
        self.id = kwargs.get(
            'id', None)
        self.info = kwargs.get(
            'info', {})
        self.name = kwargs.get(
            'name', None)
        self.predictedInsertSize = kwargs.get(
            'predictedInsertSize', None)
        self.programs = kwargs.get(
            'programs', [])
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        self.sampleId = kwargs.get(
            'sampleId', None)
        self.stats = kwargs.get(
            'stats', None)
        self.updated = kwargs.get(
            'updated', None)


class ReadGroupSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ReadGroupSet", "namespace": "org.ga4gh.models", "fields": [{"name":
"id", "type": "string", "doc": ""}, {"name": "datasetId", "type": ["null", "string"], "doc": "",
"default": null}, {"name": "name", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"stats", "type": ["null", {"type": "record", "name": "ReadStats", "fields": [{"name":
"alignedReadCount", "type": ["null", "long"], "doc": "", "default": null}, {"name":
"unalignedReadCount", "type": ["null", "long"], "doc": "", "default": null}, {"name": "baseCount",
"type": ["null", "long"], "doc": "", "default": null}]}], "doc": "", "default": null}, {"name":
"readGroups", "type": {"type": "array", "items": {"type": "record", "name": "ReadGroup", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "datasetId", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "name", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "description", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"sampleId", "type": ["null", "string"], "doc": ""}, {"name": "experiment", "type": ["null", {"type":
"record", "name": "Experiment", "doc": "", "fields": [{"name": "id", "type": "string", "doc": ""},
{"name": "name", "type": ["null", "string"], "doc": "", "default": null}, {"name": "description",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "recordCreateTime", "type":
"string", "doc": ""}, {"name": "recordUpdateTime", "type": "string", "doc": ""}, {"name": "runTime",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "molecule", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "strategy", "type": ["null", "string"], "doc": "",
"default": null}, {"name": "selection", "type": ["null", "string"], "doc": "", "default": null},
{"name": "library", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"libraryLayout", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"instrumentModel", "type": ["null", "string"], "doc": ""}, {"name": "instrumentDataFile", "type":
["null", "string"], "doc": "", "default": null}, {"name": "sequencingCenter", "type": ["null",
"string"], "doc": ""}, {"name": "platformUnit", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "info", "type": {"type": "map", "values": {"type": "array", "items": "string"}},
"doc": "", "default": {}}]}], "doc": ""}, {"name": "predictedInsertSize", "type": ["null", "int"],
"doc": "", "default": null}, {"name": "created", "type": ["null", "long"], "doc": "", "default":
null}, {"name": "updated", "type": ["null", "long"], "doc": "", "default": null}, {"name": "stats",
"type": ["null", "ReadStats"], "doc": "", "default": null}, {"name": "programs", "type": {"type":
"array", "items": {"type": "record", "name": "Program", "fields": [{"name": "commandLine", "type":
["null", "string"], "doc": "", "default": null}, {"name": "id", "type": ["null", "string"], "doc":
"", "default": null}, {"name": "name", "type": ["null", "string"], "doc": "", "default": null},
{"name": "prevProgramId", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"version", "type": ["null", "string"], "doc": "", "default": null}]}}, "doc": "", "default": []},
{"name": "referenceSetId", "type": ["null", "string"], "doc": "", "default": null}, {"name": "info",
"type": {"type": "map", "values": {"type": "array", "items": "string"}}, "doc": "", "default":
{}}]}}, "doc": "", "default": []}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'name', 'readGroups', 'stats'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        self.id = kwargs.get(
            'id', None)
        self.name = kwargs.get(
            'name', None)
        self.readGroups = kwargs.get(
            'readGroups', [])
        self.stats = kwargs.get(
            'stats', None)


class ReadStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ReadStats", "namespace": "org.ga4gh.models", "fields": [{"name":
"alignedReadCount", "type": ["null", "long"], "doc": "", "default": null}, {"name":
"unalignedReadCount", "type": ["null", "long"], "doc": "", "default": null}, {"name": "baseCount",
"type": ["null", "long"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedReadCount', 'baseCount', 'unalignedReadCount'
    ]

    def __init__(self, **kwargs):
        self.alignedReadCount = kwargs.get(
            'alignedReadCount', None)
        self.baseCount = kwargs.get(
            'baseCount', None)
        self.unalignedReadCount = kwargs.get(
            'unalignedReadCount', None)


class Reference(ProtocolElement):
    """
    A `Reference` is a canonical assembled contig, intended to act as
    a reference coordinate space for other genomic annotations. A
    single `Reference` might represent the human chromosome 1, for
    instance.  `Reference`s are designed to be immutable.
    """
    _schemaSource = """
{"type": "record", "name": "Reference", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "length", "type": "long", "doc": ""},
{"name": "md5checksum", "type": "string", "doc": ""}, {"name": "name", "type": "string", "doc": ""},
{"name": "sourceURI", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"sourceAccessions", "type": {"type": "array", "items": "string"}, "doc": ""}, {"name": "isDerived",
"type": "boolean", "doc": "", "default": false}, {"name": "sourceDivergence", "type": ["null",
"float"], "doc": "", "default": null}, {"name": "ncbiTaxonId", "type": ["null", "int"], "doc": "",
"default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "length",
        "md5checksum",
        "name",
        "sourceAccessions",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'isDerived', 'length', 'md5checksum', 'name',
        'ncbiTaxonId', 'sourceAccessions', 'sourceDivergence',
        'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        self.isDerived = kwargs.get(
            'isDerived', False)
        self.length = kwargs.get(
            'length', None)
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        self.name = kwargs.get(
            'name', None)
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        self.sourceDivergence = kwargs.get(
            'sourceDivergence', None)
        self.sourceURI = kwargs.get(
            'sourceURI', None)


class ReferenceSet(ProtocolElement):
    """
    A `ReferenceSet` is a set of `Reference`s which typically comprise
    a reference assembly, such as `GRCh38`. A `ReferenceSet` defines a
    common coordinate space for comparing reference-aligned
    experimental data.
    """
    _schemaSource = """
{"type": "record", "name": "ReferenceSet", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "md5checksum", "type": "string", "doc": ""},
{"name": "ncbiTaxonId", "type": ["null", "int"], "doc": "", "default": null}, {"name":
"description", "type": ["null", "string"], "doc": "", "default": null}, {"name": "assemblyId",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "sourceURI", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "sourceAccessions", "type": {"type": "array",
"items": "string"}, "doc": ""}, {"name": "isDerived", "type": "boolean", "doc": "", "default":
false}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "md5checksum",
        "sourceAccessions",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'assemblyId', 'description', 'id', 'isDerived', 'md5checksum',
        'ncbiTaxonId', 'sourceAccessions', 'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        self.description = kwargs.get(
            'description', None)
        self.id = kwargs.get(
            'id', None)
        self.isDerived = kwargs.get(
            'isDerived', False)
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        self.sourceURI = kwargs.get(
            'sourceURI', None)


class SearchCallSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /callsets/search` as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchCallSetsRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "variantSetId", "type": "string", "doc": ""}, {"name": "name", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "pageSize", "type": ["null", "int"], "doc": "",
"default": null}, {"name": "pageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "variantSetId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)
        self.variantSetId = kwargs.get(
            'variantSetId', None)


class SearchCallSetsResponse(SearchResponse):
    """
    This is the response from `POST /callsets/search` expressed as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchCallSetsResponse", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "callSets", "type": {"type": "array", "items": {"type": "record", "name":
"CallSet", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id", "type": "string",
"doc": ""}, {"name": "name", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"sampleId", "type": ["null", "string"], "doc": ""}, {"name": "variantSetIds", "type": {"type":
"array", "items": "string"}, "doc": "", "default": []}, {"name": "created", "type": ["null",
"long"], "doc": "", "default": null}, {"name": "updated", "type": ["null", "long"], "doc": "",
"default": null}, {"name": "info", "type": {"type": "map", "values": {"type": "array", "items":
"string"}}, "doc": "", "default": {}}]}}, "doc": "", "default": []}, {"name": "nextPageToken",
"type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "callSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.callSets = kwargs.get(
            'callSets', [])
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)


class SearchDatasetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /datasets/search` as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchDatasetsRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "pageSize", "type": ["null", "int"], "doc": "", "default": null}, {"name":
"pageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)


class SearchDatasetsResponse(SearchResponse):
    """
    This is the response from `POST /datasets/search` expressed as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchDatasetsResponse", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "datasets", "type": {"type": "array", "items": {"type": "record", "name":
"Dataset", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id", "type": "string",
"doc": ""}, {"name": "description", "type": ["null", "string"], "doc": "", "default": null}]}},
"doc": "", "default": []}, {"name": "nextPageToken", "type": ["null", "string"], "doc": "",
"default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "datasets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.datasets = kwargs.get(
            'datasets', [])
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)


class SearchReadGroupSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /readgroupsets/search` as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReadGroupSetsRequest", "namespace": "org.ga4gh.methods", "doc":
"", "fields": [{"name": "datasetId", "type": "string", "doc": ""}, {"name": "name", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "pageSize", "type": ["null", "int"], "doc": "",
"default": null}, {"name": "pageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "datasetId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        self.name = kwargs.get(
            'name', None)
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)


class SearchReadGroupSetsResponse(SearchResponse):
    """
    This is the response from `POST /readgroupsets/search` expressed
    as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReadGroupSetsResponse", "namespace": "org.ga4gh.methods", "doc":
"", "fields": [{"name": "readGroupSets", "type": {"type": "array", "items": {"type": "record",
"name": "ReadGroupSet", "namespace": "org.ga4gh.models", "fields": [{"name": "id", "type": "string",
"doc": ""}, {"name": "datasetId", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"name", "type": ["null", "string"], "doc": "", "default": null}, {"name": "stats", "type": ["null",
{"type": "record", "name": "ReadStats", "fields": [{"name": "alignedReadCount", "type": ["null",
"long"], "doc": "", "default": null}, {"name": "unalignedReadCount", "type": ["null", "long"],
"doc": "", "default": null}, {"name": "baseCount", "type": ["null", "long"], "doc": "", "default":
null}]}], "doc": "", "default": null}, {"name": "readGroups", "type": {"type": "array", "items":
{"type": "record", "name": "ReadGroup", "fields": [{"name": "id", "type": "string", "doc": ""},
{"name": "datasetId", "type": ["null", "string"], "doc": "", "default": null}, {"name": "name",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "description", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "sampleId", "type": ["null", "string"], "doc": ""},
{"name": "experiment", "type": ["null", {"type": "record", "name": "Experiment", "doc": "",
"fields": [{"name": "id", "type": "string", "doc": ""}, {"name": "name", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "description", "type": ["null", "string"], "doc": "",
"default": null}, {"name": "recordCreateTime", "type": "string", "doc": ""}, {"name":
"recordUpdateTime", "type": "string", "doc": ""}, {"name": "runTime", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "molecule", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "strategy", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"selection", "type": ["null", "string"], "doc": "", "default": null}, {"name": "library", "type":
["null", "string"], "doc": "", "default": null}, {"name": "libraryLayout", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "instrumentModel", "type": ["null", "string"],
"doc": ""}, {"name": "instrumentDataFile", "type": ["null", "string"], "doc": "", "default": null},
{"name": "sequencingCenter", "type": ["null", "string"], "doc": ""}, {"name": "platformUnit",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "info", "type": {"type": "map",
"values": {"type": "array", "items": "string"}}, "doc": "", "default": {}}]}], "doc": ""}, {"name":
"predictedInsertSize", "type": ["null", "int"], "doc": "", "default": null}, {"name": "created",
"type": ["null", "long"], "doc": "", "default": null}, {"name": "updated", "type": ["null", "long"],
"doc": "", "default": null}, {"name": "stats", "type": ["null", "ReadStats"], "doc": "", "default":
null}, {"name": "programs", "type": {"type": "array", "items": {"type": "record", "name": "Program",
"fields": [{"name": "commandLine", "type": ["null", "string"], "doc": "", "default": null}, {"name":
"id", "type": ["null", "string"], "doc": "", "default": null}, {"name": "name", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "prevProgramId", "type": ["null", "string"], "doc":
"", "default": null}, {"name": "version", "type": ["null", "string"], "doc": "", "default":
null}]}}, "doc": "", "default": []}, {"name": "referenceSetId", "type": ["null", "string"], "doc":
"", "default": null}, {"name": "info", "type": {"type": "map", "values": {"type": "array", "items":
"string"}}, "doc": "", "default": {}}]}}, "doc": "", "default": []}]}}, "doc": "", "default": []},
{"name": "nextPageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "readGroupSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'readGroupSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        self.readGroupSets = kwargs.get(
            'readGroupSets', [])


class SearchReadsRequest(SearchRequest):
    """
    This request maps to the body of `POST /reads/search` as JSON.  If
    a reference is specified, all queried `ReadGroup`s must be aligned
    to `ReferenceSet`s containing that same `Reference`. If no
    reference is specified, all `ReadGroup`s must be aligned to the
    same `ReferenceSet`.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReadsRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "readGroupIds", "type": {"type": "array", "items": "string"}, "doc": ""},
{"name": "referenceId", "type": ["null", "string"], "doc": "", "default": null}, {"name": "start",
"type": ["null", "long"], "doc": "", "default": null}, {"name": "end", "type": ["null", "long"],
"doc": "", "default": null}, {"name": "pageSize", "type": ["null", "int"], "doc": "", "default":
null}, {"name": "pageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "readGroupIds",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'readGroupIds', 'referenceId',
        'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)
        self.readGroupIds = kwargs.get(
            'readGroupIds', None)
        self.referenceId = kwargs.get(
            'referenceId', None)
        self.start = kwargs.get(
            'start', None)


class SearchReadsResponse(SearchResponse):
    """
    This is the response from `POST /reads/search` expressed as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReadsResponse", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "alignments", "type": {"type": "array", "items": {"type": "record", "name":
"ReadAlignment", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id", "type":
["null", "string"], "doc": ""}, {"name": "readGroupId", "type": "string", "doc": ""}, {"name":
"fragmentId", "type": "string", "doc": ""}, {"name": "fragmentName", "type": "string", "doc": ""},
{"name": "properPlacement", "type": ["null", "boolean"], "doc": "", "default": null}, {"name":
"duplicateFragment", "type": ["null", "boolean"], "doc": "", "default": null}, {"name":
"numberReads", "type": ["null", "int"], "doc": "", "default": null}, {"name": "fragmentLength",
"type": ["null", "int"], "doc": "", "default": null}, {"name": "readNumber", "type": ["null",
"int"], "doc": "", "default": null}, {"name": "failedVendorQualityChecks", "type": ["null",
"boolean"], "doc": "", "default": null}, {"name": "alignment", "type": ["null", {"type": "record",
"name": "LinearAlignment", "doc": "", "fields": [{"name": "position", "type": {"type": "record",
"name": "Position", "doc": "", "fields": [{"name": "referenceName", "type": "string", "doc": ""},
{"name": "position", "type": "long", "doc": ""}, {"name": "strand", "type": {"type": "enum", "name":
"Strand", "doc": "", "symbols": ["NEG_STRAND", "POS_STRAND"]}, "doc": ""}]}, "doc": ""}, {"name":
"mappingQuality", "type": ["null", "int"], "doc": "", "default": null}, {"name": "cigar", "type":
{"type": "array", "items": {"type": "record", "name": "CigarUnit", "doc": "", "fields": [{"name":
"operation", "type": {"type": "enum", "name": "CigarOperation", "doc": "", "symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"]}, "doc": ""}, {"name": "operationLength", "type": "long", "doc": ""}, {"name":
"referenceSequence", "type": ["null", "string"], "doc": "", "default": null}]}}, "doc": "",
"default": []}]}], "doc": "", "default": null}, {"name": "secondaryAlignment", "type": ["null",
"boolean"], "doc": "", "default": null}, {"name": "supplementaryAlignment", "type": ["null",
"boolean"], "doc": "", "default": null}, {"name": "alignedSequence", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "alignedQuality", "type": {"type": "array", "items": "int"},
"doc": "", "default": []}, {"name": "nextMatePosition", "type": ["null", "Position"], "doc": "",
"default": null}, {"name": "info", "type": {"type": "map", "values": {"type": "array", "items":
"string"}}, "doc": "", "default": {}}]}}, "doc": "", "default": []}, {"name": "nextPageToken",
"type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "alignments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignments', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.alignments = kwargs.get(
            'alignments', [])
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)


class SearchReferenceSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /referencesets/search` as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReferenceSetsRequest", "namespace": "org.ga4gh.methods", "doc":
"", "fields": [{"name": "md5checksums", "type": {"type": "array", "items": "string"}, "doc": "",
"default": []}, {"name": "accessions", "type": {"type": "array", "items": "string"}, "doc": "",
"default": []}, {"name": "assemblyId", "type": ["null", "string"], "doc": "", "default": null},
{"name": "pageSize", "type": ["null", "int"], "doc": "", "default": null}, {"name": "pageToken",
"type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'assemblyId', 'md5checksums', 'pageSize',
        'pageToken'
    ]

    def __init__(self, **kwargs):
        self.accessions = kwargs.get(
            'accessions', [])
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        self.md5checksums = kwargs.get(
            'md5checksums', [])
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)


class SearchReferenceSetsResponse(SearchResponse):
    """
    This is the response from `POST /referencesets/search` expressed
    as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReferenceSetsResponse", "namespace": "org.ga4gh.methods", "doc":
"", "fields": [{"name": "referenceSets", "type": {"type": "array", "items": {"type": "record",
"name": "ReferenceSet", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id",
"type": "string", "doc": ""}, {"name": "md5checksum", "type": "string", "doc": ""}, {"name":
"ncbiTaxonId", "type": ["null", "int"], "doc": "", "default": null}, {"name": "description", "type":
["null", "string"], "doc": "", "default": null}, {"name": "assemblyId", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "sourceURI", "type": ["null", "string"], "doc": "", "default":
null}, {"name": "sourceAccessions", "type": {"type": "array", "items": "string"}, "doc": ""},
{"name": "isDerived", "type": "boolean", "doc": "", "default": false}]}}, "doc": "", "default": []},
{"name": "nextPageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "referenceSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'referenceSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        self.referenceSets = kwargs.get(
            'referenceSets', [])


class SearchReferencesRequest(SearchRequest):
    """
    This request maps to the body of `POST /references/search` as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReferencesRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "referenceSetId", "type": ["null", "string"], "doc": "", "default": null},
{"name": "md5checksums", "type": {"type": "array", "items": "string"}, "doc": "", "default": []},
{"name": "accessions", "type": {"type": "array", "items": "string"}, "doc": "", "default": []},
{"name": "pageSize", "type": ["null", "int"], "doc": "", "default": null}, {"name": "pageToken",
"type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'md5checksums', 'pageSize', 'pageToken',
        'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.accessions = kwargs.get(
            'accessions', [])
        self.md5checksums = kwargs.get(
            'md5checksums', [])
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)


class SearchReferencesResponse(SearchResponse):
    """
    This is the response from `POST /references/search` expressed as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchReferencesResponse", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "references", "type": {"type": "array", "items": {"type": "record", "name":
"Reference", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id", "type": "string",
"doc": ""}, {"name": "length", "type": "long", "doc": ""}, {"name": "md5checksum", "type": "string",
"doc": ""}, {"name": "name", "type": "string", "doc": ""}, {"name": "sourceURI", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "sourceAccessions", "type": {"type": "array",
"items": "string"}, "doc": ""}, {"name": "isDerived", "type": "boolean", "doc": "", "default":
false}, {"name": "sourceDivergence", "type": ["null", "float"], "doc": "", "default": null},
{"name": "ncbiTaxonId", "type": ["null", "int"], "doc": "", "default": null}]}}, "doc": "",
"default": []}, {"name": "nextPageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "references"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'references'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        self.references = kwargs.get(
            'references', [])


class SearchVariantSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /variantsets/search` as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchVariantSetsRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "datasetId", "type": "string", "doc": ""}, {"name": "pageSize", "type": ["null",
"int"], "doc": "", "default": null}, {"name": "pageToken", "type": ["null", "string"], "doc": "",
"default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "datasetId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)


class SearchVariantSetsResponse(SearchResponse):
    """
    This is the response from `POST /variantsets/search` expressed as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchVariantSetsResponse", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "variantSets", "type": {"type": "array", "items": {"type": "record", "name":
"VariantSet", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id", "type":
"string", "doc": ""}, {"name": "datasetId", "type": "string", "doc": ""}, {"name": "referenceSetId",
"type": "string", "doc": ""}, {"name": "metadata", "type": {"type": "array", "items": {"type":
"record", "name": "VariantSetMetadata", "doc": "", "fields": [{"name": "key", "type": "string",
"doc": ""}, {"name": "value", "type": "string", "doc": ""}, {"name": "id", "type": "string", "doc":
""}, {"name": "type", "type": "string", "doc": ""}, {"name": "number", "type": "string", "doc": ""},
{"name": "description", "type": "string", "doc": ""}, {"name": "info", "type": {"type": "map",
"values": {"type": "array", "items": "string"}}, "doc": "", "default": {}}]}}, "doc": "", "default":
[]}]}}, "doc": "", "default": []}, {"name": "nextPageToken", "type": ["null", "string"], "doc": "",
"default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "variantSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        self.variantSets = kwargs.get(
            'variantSets', [])


class SearchVariantsRequest(SearchRequest):
    """
    This request maps to the body of `POST /variants/search` as JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchVariantsRequest", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "variantSetId", "type": "string", "doc": ""}, {"name": "callSetIds", "type":
["null", {"type": "array", "items": "string"}], "doc": "", "default": null}, {"name":
"referenceName", "type": "string", "doc": ""}, {"name": "start", "type": "long", "doc": ""},
{"name": "end", "type": "long", "doc": ""}, {"name": "pageSize", "type": ["null", "int"], "doc": "",
"default": null}, {"name": "pageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "end",
        "referenceName",
        "start",
        "variantSetId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetIds', 'end', 'pageSize', 'pageToken', 'referenceName',
        'start', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.callSetIds = kwargs.get(
            'callSetIds', None)
        self.end = kwargs.get(
            'end', None)
        self.pageSize = kwargs.get(
            'pageSize', None)
        self.pageToken = kwargs.get(
            'pageToken', None)
        self.referenceName = kwargs.get(
            'referenceName', None)
        self.start = kwargs.get(
            'start', None)
        self.variantSetId = kwargs.get(
            'variantSetId', None)


class SearchVariantsResponse(SearchResponse):
    """
    This is the response from `POST /variants/search` expressed as
    JSON.
    """
    _schemaSource = """
{"type": "record", "name": "SearchVariantsResponse", "namespace": "org.ga4gh.methods", "doc": "",
"fields": [{"name": "variants", "type": {"type": "array", "items": {"type": "record", "name":
"Variant", "namespace": "org.ga4gh.models", "doc": "", "fields": [{"name": "id", "type": "string",
"doc": ""}, {"name": "variantSetId", "type": "string", "doc": ""}, {"name": "names", "type":
{"type": "array", "items": "string"}, "doc": "", "default": []}, {"name": "created", "type":
["null", "long"], "doc": "", "default": null}, {"name": "updated", "type": ["null", "long"], "doc":
"", "default": null}, {"name": "referenceName", "type": "string", "doc": ""}, {"name": "start",
"type": "long", "doc": ""}, {"name": "end", "type": "long", "doc": ""}, {"name": "referenceBases",
"type": "string", "doc": ""}, {"name": "alternateBases", "type": {"type": "array", "items":
"string"}, "doc": "", "default": []}, {"name": "info", "type": {"type": "map", "values": {"type":
"array", "items": "string"}}, "doc": "", "default": {}}, {"name": "calls", "type": {"type": "array",
"items": {"type": "record", "name": "Call", "doc": "", "fields": [{"name": "callSetName", "type":
["null", "string"], "doc": "", "default": null}, {"name": "callSetId", "type": ["null", "string"],
"doc": "", "default": null}, {"name": "genotype", "type": {"type": "array", "items": "int"}, "doc":
"", "default": []}, {"name": "phaseset", "type": ["null", "string"], "doc": "", "default": null},
{"name": "genotypeLikelihood", "type": {"type": "array", "items": "double"}, "doc": "", "default":
[]}, {"name": "info", "type": {"type": "map", "values": {"type": "array", "items": "string"}},
"doc": "", "default": {}}]}}, "doc": "", "default": []}]}}, "doc": "", "default": []}, {"name":
"nextPageToken", "type": ["null", "string"], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {}
    _valueListName = "variants"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variants'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        self.variants = kwargs.get(
            'variants', [])


class Strand(object):
    """
    Indicates the DNA strand associate for some data item. *
    `NEG_STRAND`: The negative (-) strand. * `POS_STRAND`:  The
    postive (+) strand.
    """
    NEG_STRAND = "NEG_STRAND"
    POS_STRAND = "POS_STRAND"

    def __hash__(self):
        return str(self).__hash__()


class Variant(ProtocolElement):
    """
    A `Variant` represents a change in DNA sequence relative to some
    reference. For example, a variant could represent a SNP or an
    insertion. Variants belong to a `VariantSet`. This is equivalent
    to a row in VCF.
    """
    _schemaSource = """
{"type": "record", "name": "Variant", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "variantSetId", "type": "string", "doc": ""},
{"name": "names", "type": {"type": "array", "items": "string"}, "doc": "", "default": []}, {"name":
"created", "type": ["null", "long"], "doc": "", "default": null}, {"name": "updated", "type":
["null", "long"], "doc": "", "default": null}, {"name": "referenceName", "type": "string", "doc":
""}, {"name": "start", "type": "long", "doc": ""}, {"name": "end", "type": "long", "doc": ""},
{"name": "referenceBases", "type": "string", "doc": ""}, {"name": "alternateBases", "type": {"type":
"array", "items": "string"}, "doc": "", "default": []}, {"name": "info", "type": {"type": "map",
"values": {"type": "array", "items": "string"}}, "doc": "", "default": {}}, {"name": "calls",
"type": {"type": "array", "items": {"type": "record", "name": "Call", "doc": "", "fields": [{"name":
"callSetName", "type": ["null", "string"], "doc": "", "default": null}, {"name": "callSetId",
"type": ["null", "string"], "doc": "", "default": null}, {"name": "genotype", "type": {"type":
"array", "items": "int"}, "doc": "", "default": []}, {"name": "phaseset", "type": ["null",
"string"], "doc": "", "default": null}, {"name": "genotypeLikelihood", "type": {"type": "array",
"items": "double"}, "doc": "", "default": []}, {"name": "info", "type": {"type": "map", "values":
{"type": "array", "items": "string"}}, "doc": "", "default": {}}]}}, "doc": "", "default": []}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "end",
        "id",
        "referenceBases",
        "referenceName",
        "start",
        "variantSetId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternateBases', 'calls', 'created', 'end', 'id', 'info',
        'names', 'referenceBases', 'referenceName', 'start',
        'updated', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.alternateBases = kwargs.get(
            'alternateBases', [])
        self.calls = kwargs.get(
            'calls', [])
        self.created = kwargs.get(
            'created', None)
        self.end = kwargs.get(
            'end', None)
        self.id = kwargs.get(
            'id', None)
        self.info = kwargs.get(
            'info', {})
        self.names = kwargs.get(
            'names', [])
        self.referenceBases = kwargs.get(
            'referenceBases', None)
        self.referenceName = kwargs.get(
            'referenceName', None)
        self.start = kwargs.get(
            'start', None)
        self.updated = kwargs.get(
            'updated', None)
        self.variantSetId = kwargs.get(
            'variantSetId', None)


class VariantSet(ProtocolElement):
    """
    `Variant` and `CallSet` both belong to a `VariantSet`.
    `VariantSet` belongs to a `Dataset`. The variant set is equivalent
    to a VCF file.
    """
    _schemaSource = """
{"type": "record", "name": "VariantSet", "namespace": "org.ga4gh.models", "doc": "", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "datasetId", "type": "string", "doc": ""},
{"name": "referenceSetId", "type": "string", "doc": ""}, {"name": "metadata", "type": {"type":
"array", "items": {"type": "record", "name": "VariantSetMetadata", "doc": "", "fields": [{"name":
"key", "type": "string", "doc": ""}, {"name": "value", "type": "string", "doc": ""}, {"name": "id",
"type": "string", "doc": ""}, {"name": "type", "type": "string", "doc": ""}, {"name": "number",
"type": "string", "doc": ""}, {"name": "description", "type": "string", "doc": ""}, {"name": "info",
"type": {"type": "map", "values": {"type": "array", "items": "string"}}, "doc": "", "default":
{}}]}}, "doc": "", "default": []}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "datasetId",
        "id",
        "referenceSetId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'metadata', 'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        self.id = kwargs.get(
            'id', None)
        self.metadata = kwargs.get(
            'metadata', [])
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)


class VariantSetMetadata(ProtocolElement):
    """
    This metadata represents VCF header information.
    """
    _schemaSource = """
{"type": "record", "name": "VariantSetMetadata", "namespace": "org.ga4gh.models", "doc": "",
"fields": [{"name": "key", "type": "string", "doc": ""}, {"name": "value", "type": "string", "doc":
""}, {"name": "id", "type": "string", "doc": ""}, {"name": "type", "type": "string", "doc": ""},
{"name": "number", "type": "string", "doc": ""}, {"name": "description", "type": "string", "doc":
""}, {"name": "info", "type": {"type": "map", "values": {"type": "array", "items": "string"}},
"doc": "", "default": {}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "description",
        "id",
        "key",
        "number",
        "type",
        "value",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'key', 'number', 'type', 'value'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        self.id = kwargs.get(
            'id', None)
        self.info = kwargs.get(
            'info', {})
        self.key = kwargs.get(
            'key', None)
        self.number = kwargs.get(
            'number', None)
        self.type = kwargs.get(
            'type', None)
        self.value = kwargs.get(
            'value', None)
