"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GEL protocol classes, please run the script
on the appropriate schema version.
"""
from protocols.protocol import ProtocolElement
from protocols.protocol import SearchRequest
from protocols.protocol import SearchResponse
from protocols.protocol import avro_parse

import avro.schema

version = '1.2.0'


class AdditionalAttribute(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "AdditionalAttribute", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "attribute", "type": {"type": "map",
"values": "string"}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "attribute",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'attribute'
    ]

    def __init__(self, **kwargs):
        self.attribute = kwargs.get(
            'attribute', None)


class Aggregation(object):
    """
    No documentation
    """
    NONE = "NONE"
    BASIC = "BASIC"
    EVS = "EVS"
    EXAC = "EXAC"

    def __hash__(self):
        return str(self).__hash__()


class AlleleOrigin(object):
    """
    Variant origin.  * `SO_0001781`: de novo variant.
    http://purl.obolibrary.org/obo/SO_0001781 * `SO_0001778`: germline
    variant. http://purl.obolibrary.org/obo/SO_0001778 * `SO_0001775`:
    maternal variant. http://purl.obolibrary.org/obo/SO_0001775 *
    `SO_0001776`: paternal variant.
    http://purl.obolibrary.org/obo/SO_0001776 * `SO_0001779`: pedigree
    specific variant. http://purl.obolibrary.org/obo/SO_0001779 *
    `SO_0001780`: population specific variant.
    http://purl.obolibrary.org/obo/SO_0001780 * `SO_0001777`: somatic
    variant. http://purl.obolibrary.org/obo/SO_0001777
    """
    de_novo_variant = "de_novo_variant"
    germline_variant = "germline_variant"
    maternal_variant = "maternal_variant"
    paternal_variant = "paternal_variant"
    pedigree_specific_variant = "pedigree_specific_variant"
    population_specific_variant = "population_specific_variant"
    somatic_variant = "somatic_variant"

    def __hash__(self):
        return str(self).__hash__()


class AllelesCode(object):
    """
    No documentation
    """
    ALLELES_OK = "ALLELES_OK"
    ALLELES_MISSING = "ALLELES_MISSING"
    MULTIPLE_ALTERNATES = "MULTIPLE_ALTERNATES"
    HAPLOID = "HAPLOID"

    def __hash__(self):
        return str(self).__hash__()


class AlternateCoordinate(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "AlternateCoordinate", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "chromosome", "type": ["null",
"string"]}, {"name": "start", "type": ["null", "int"], "doc": ""}, {"name": "end", "type": ["null",
"int"], "doc": ""}, {"name": "reference", "type": ["null", "string"], "doc": ""}, {"name":
"alternate", "type": "string", "doc": ""}, {"name": "type", "type": {"type": "enum", "name":
"VariantType", "doc": "", "symbols": ["SNV", "SNP", "MNV", "MNP", "INDEL", "SV", "INSERTION",
"DELETION", "TRANSLOCATION", "INVERSION", "CNV", "DUPLICATION", "BREAKEND", "NO_VARIATION",
"SYMBOLIC", "MIXED"]}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "alternate",
        "chromosome",
        "end",
        "reference",
        "start",
        "type",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternate', 'chromosome', 'end', 'reference', 'start', 'type'
    ]

    def __init__(self, **kwargs):
        self.alternate = kwargs.get(
            'alternate', None)
        self.chromosome = kwargs.get(
            'chromosome', None)
        self.end = kwargs.get(
            'end', None)
        self.reference = kwargs.get(
            'reference', None)
        self.start = kwargs.get(
            'start', None)
        self.type = kwargs.get(
            'type', None)


class ClinVar(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ClinVar", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "accession", "type": "string"}, {"name": "clinicalSignificance", "type":
"string"}, {"name": "traits", "type": {"type": "array", "items": "string"}}, {"name": "geneNames",
"type": {"type": "array", "items": "string"}}, {"name": "reviewStatus", "type": "string"}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "accession",
        "clinicalSignificance",
        "geneNames",
        "reviewStatus",
        "traits",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accession', 'clinicalSignificance', 'geneNames',
        'reviewStatus', 'traits'
    ]

    def __init__(self, **kwargs):
        self.accession = kwargs.get(
            'accession', None)
        self.clinicalSignificance = kwargs.get(
            'clinicalSignificance', None)
        self.geneNames = kwargs.get(
            'geneNames', None)
        self.reviewStatus = kwargs.get(
            'reviewStatus', None)
        self.traits = kwargs.get(
            'traits', None)


class ClinicalSignificance(object):
    """
    Mendelian variants classification with ACMG terminology as defined
    in Richards, S. et al. (2015). Standards and         guidelines
    for the interpretation of sequence variants: a joint consensus
    recommendation of the American College         of Medical Genetics
    and Genomics and the Association for Molecular Pathology. Genetics
    in Medicine, 17(5),         405?423.
    https://doi.org/10.1038/gim.2015.30.      Classification for
    pharmacogenomic variants, variants associated to     disease and
    somatic variants based on the ACMG recommendations and ClinVar
    classification
    (https://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/).  *
    `benign_variant` : Benign variants interpreted for Mendelian
    disorders * `likely_benign_variant` : Likely benign variants
    interpreted for Mendelian disorders with a certainty of at least
    90% * `pathogenic_variant` : Pathogenic variants interpreted for
    Mendelian disorders * `likely_pathogenic_variant` : Likely
    pathogenic variants interpreted for Mendelian disorders with a
    certainty of at least 90% * `uncertain_significance` : Uncertain
    significance variants interpreted for Mendelian disorders.
    Variants with conflicting evidences should be classified as
    uncertain_significance
    """
    benign = "benign"
    likely_benign = "likely_benign"
    VUS = "VUS"
    likely_pathogenic = "likely_pathogenic"
    pathogenic = "pathogenic"
    uncertain_significance = "uncertain_significance"

    def __hash__(self):
        return str(self).__hash__()


class Confidence(object):
    """
    Confidence based on the Confidence Information Ontology  *
    `CIO_0000029`: high confidence level
    http://purl.obolibrary.org/obo/CIO_0000029 * `CIO_0000031`: low
    confidence level http://purl.obolibrary.org/obo/CIO_0000031 *
    `CIO_0000030`: medium confidence level
    http://purl.obolibrary.org/obo/CIO_0000030 * `CIO_0000039`:
    rejected http://purl.obolibrary.org/obo/CIO_0000039
    """
    low_confidence_level = "low_confidence_level"
    medium_confidence_level = "medium_confidence_level"
    high_confidence_level = "high_confidence_level"
    rejected = "rejected"

    def __hash__(self):
        return str(self).__hash__()


class ConsequenceType(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ConsequenceType", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "geneName", "type": ["null", "string"]}, {"name": "ensemblGeneId", "type":
["null", "string"]}, {"name": "ensemblTranscriptId", "type": ["null", "string"]}, {"name": "strand",
"type": ["null", "string"]}, {"name": "biotype", "type": ["null", "string"]}, {"name":
"exonOverlap", "type": ["null", {"type": "array", "items": {"type": "record", "name": "ExonOverlap",
"fields": [{"name": "number", "type": ["null", "string"]}, {"name": "percentage", "type": ["null",
"float"]}]}}]}, {"name": "transcriptAnnotationFlags", "type": ["null", {"type": "array", "items":
"string"}]}, {"name": "cdnaPosition", "type": ["null", "int"]}, {"name": "cdsPosition", "type":
["null", "int"]}, {"name": "codon", "type": ["null", "string"]}, {"name":
"proteinVariantAnnotation", "type": ["null", {"type": "record", "name": "ProteinVariantAnnotation",
"fields": [{"name": "uniprotAccession", "type": ["null", "string"], "default": null}, {"name":
"uniprotName", "type": ["null", "string"], "default": null}, {"name": "position", "type": "int"},
{"name": "reference", "type": ["null", "string"]}, {"name": "alternate", "type": ["null",
"string"]}, {"name": "uniprotVariantId", "type": ["null", "string"]}, {"name":
"functionalDescription", "type": ["null", "string"]}, {"name": "substitutionScores", "type":
["null", {"type": "array", "items": {"type": "record", "name": "Score", "fields": [{"name": "score",
"type": "double"}, {"name": "source", "type": "string"}, {"name": "description", "type": ["null",
"string"]}]}}]}, {"name": "keywords", "type": ["null", {"type": "array", "items": "string"}]},
{"name": "features", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"ProteinFeature", "fields": [{"name": "id", "type": ["null", "string"]}, {"name": "start", "type":
"int"}, {"name": "end", "type": "int"}, {"name": "type", "type": ["null", "string"]}, {"name":
"description", "type": ["null", "string"]}]}}]}]}]}, {"name": "sequenceOntologyTerms", "type":
{"type": "array", "items": {"type": "record", "name": "SequenceOntologyTerm", "fields": [{"name":
"accession", "type": "string"}, {"name": "name", "type": "string"}]}}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "biotype",
        "cdnaPosition",
        "cdsPosition",
        "codon",
        "ensemblGeneId",
        "ensemblTranscriptId",
        "exonOverlap",
        "geneName",
        "proteinVariantAnnotation",
        "sequenceOntologyTerms",
        "strand",
        "transcriptAnnotationFlags",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'exonOverlap': ExonOverlap,
            'proteinVariantAnnotation': ProteinVariantAnnotation,
            'sequenceOntologyTerms': SequenceOntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'exonOverlap': ExonOverlap,
            'proteinVariantAnnotation': ProteinVariantAnnotation,
            'sequenceOntologyTerms': SequenceOntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'biotype', 'cdnaPosition', 'cdsPosition', 'codon',
        'ensemblGeneId', 'ensemblTranscriptId', 'exonOverlap',
        'geneName', 'proteinVariantAnnotation',
        'sequenceOntologyTerms', 'strand', 'transcriptAnnotationFlags'
    ]

    def __init__(self, **kwargs):
        self.biotype = kwargs.get(
            'biotype', None)
        self.cdnaPosition = kwargs.get(
            'cdnaPosition', None)
        self.cdsPosition = kwargs.get(
            'cdsPosition', None)
        self.codon = kwargs.get(
            'codon', None)
        self.ensemblGeneId = kwargs.get(
            'ensemblGeneId', None)
        self.ensemblTranscriptId = kwargs.get(
            'ensemblTranscriptId', None)
        self.exonOverlap = kwargs.get(
            'exonOverlap', None)
        self.geneName = kwargs.get(
            'geneName', None)
        self.proteinVariantAnnotation = kwargs.get(
            'proteinVariantAnnotation', None)
        self.sequenceOntologyTerms = kwargs.get(
            'sequenceOntologyTerms', None)
        self.strand = kwargs.get(
            'strand', None)
        self.transcriptAnnotationFlags = kwargs.get(
            'transcriptAnnotationFlags', None)


class ConsistencyStatus(object):
    """
    The consistency of evidences for a given phenotype. This
    aggregates all evidences for a given phenotype and all
    evidences with no phenotype associated (e.g.: in silico impact
    prediction, population frequency).     This is based on the
    Confidence Information Ontology terms.  * `CIO_0000033`:
    congruent, all evidences are consistent.
    http://purl.obolibrary.org/obo/CIO_0000033 * `CIO_0000034`:
    conflict, there are conflicting evidences. This should correspond
    to a `VariantClassification` of `uncertain_significance` for
    mendelian disorders. http://purl.obolibrary.org/obo/CIO_0000034 *
    `CIO_0000035`: strongly conflicting.
    http://purl.obolibrary.org/obo/CIO_0000035 * `CIO_0000036`: weakly
    conflicting. http://purl.obolibrary.org/obo/CIO_0000036
    """
    congruent = "congruent"
    conflict = "conflict"
    weakly_conflicting = "weakly_conflicting"
    strongly_conflicting = "strongly_conflicting"

    def __hash__(self):
        return str(self).__hash__()


class Cosmic(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Cosmic", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "mutationId", "type": "string"}, {"name": "primarySite", "type": "string"},
{"name": "siteSubtype", "type": "string"}, {"name": "primaryHistology", "type": "string"}, {"name":
"histologySubtype", "type": "string"}, {"name": "sampleSource", "type": "string"}, {"name":
"tumourOrigin", "type": "string"}, {"name": "geneName", "type": "string"}, {"name":
"mutationSomaticStatus", "type": "string"}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "geneName",
        "histologySubtype",
        "mutationId",
        "mutationSomaticStatus",
        "primaryHistology",
        "primarySite",
        "sampleSource",
        "siteSubtype",
        "tumourOrigin",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'geneName', 'histologySubtype', 'mutationId',
        'mutationSomaticStatus', 'primaryHistology', 'primarySite',
        'sampleSource', 'siteSubtype', 'tumourOrigin'
    ]

    def __init__(self, **kwargs):
        self.geneName = kwargs.get(
            'geneName', None)
        self.histologySubtype = kwargs.get(
            'histologySubtype', None)
        self.mutationId = kwargs.get(
            'mutationId', None)
        self.mutationSomaticStatus = kwargs.get(
            'mutationSomaticStatus', None)
        self.primaryHistology = kwargs.get(
            'primaryHistology', None)
        self.primarySite = kwargs.get(
            'primarySite', None)
        self.sampleSource = kwargs.get(
            'sampleSource', None)
        self.siteSubtype = kwargs.get(
            'siteSubtype', None)
        self.tumourOrigin = kwargs.get(
            'tumourOrigin', None)


class Cytoband(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Cytoband", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "stain", "type": ["null", "string"]}, {"name": "name", "type": ["null",
"string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type": ["null", "int"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "end",
        "name",
        "stain",
        "start",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'name', 'stain', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        self.name = kwargs.get(
            'name', None)
        self.stain = kwargs.get(
            'stain', None)
        self.start = kwargs.get(
            'start', None)


class DrugResponseClassification(object):
    """
    Pharmacogenomics drug response variant classification *
    `responsive` : A variant that confers response to a treatment *
    `resistant` : A variant that confers resistance to a treatment *
    `toxicity` : A variant that is associated with drug-induced
    toxicity * `indication` : A variant that is required in order for
    a particular drug to be prescribed * `contraindication` : A
    variant that if present, a particular drug should not be
    prescribed * `dosing` : A variant that results in an alteration in
    dosing of a particular drug in order to achieve INR, reduce
    toxicity or increase efficacy * `increased_monitoring` : increase
    vigilance or increased dosage monitoring may be required for a
    patient with this variant to look for signs of adverse drug
    reactions * `efficacy` : a variant that affects the efficacy of
    the treatment
    """
    responsive = "responsive"
    resistant = "resistant"
    toxicity = "toxicity"
    indication = "indication"
    contraindication = "contraindication"
    dosing = "dosing"
    increased_monitoring = "increased_monitoring"
    efficacy = "efficacy"

    def __hash__(self):
        return str(self).__hash__()


class EthnicCategory(object):
    """
    This is the list of ethnics in ONS16  * `D`:  Mixed: White and
    Black Caribbean * `E`:  Mixed: White and Black African * `F`:
    Mixed: White and Asian * `G`:  Mixed: Any other mixed background *
    `A`:  White: British * `B`:  White: Irish * `C`:  White: Any other
    White background * `L`:  Asian or Asian British: Any other Asian
    background * `M`:  Black or Black British: Caribbean * `N`:  Black
    or Black British: African * `H`:  Asian or Asian British: Indian *
    `J`:  Asian or Asian British: Pakistani * `K`:  Asian or Asian
    British: Bangladeshi * `P`:  Black or Black British: Any other
    Black background * `S`:  Other Ethnic Groups: Any other ethnic
    group * `R`:  Other Ethnic Groups: Chinese * `Z`:  Not stated
    """
    D = "D"
    E = "E"
    F = "F"
    G = "G"
    A = "A"
    B = "B"
    C = "C"
    L = "L"
    M = "M"
    N = "N"
    H = "H"
    J = "J"
    K = "K"
    P = "P"
    S = "S"
    R = "R"
    Z = "Z"

    def __hash__(self):
        return str(self).__hash__()


class EvidenceEntry(ProtocolElement):
    """
    An entry for an evidence
    """
    _schemaSource = """
{"type": "record", "name": "EvidenceEntry", "namespace": "org.opencb.biodata.models.variant.avro",
"doc": "", "fields": [{"name": "source", "type": {"type": "record", "name": "EvidenceSource", "doc":
"", "fields": [{"name": "name", "type": ["null", "string"], "doc": ""}, {"name": "version", "type":
["null", "string"], "doc": ""}, {"name": "date", "type": ["null", "string"], "doc": ""}]}, "doc":
""}, {"name": "submissions", "type": {"type": "array", "items": {"type": "record", "name":
"EvidenceSubmission", "doc": "", "fields": [{"name": "submitter", "type": ["null", "string"], "doc":
""}, {"name": "date", "type": ["null", "string"], "doc": ""}, {"name": "id", "type": ["null",
"string"], "doc": ""}]}}, "doc": "", "default": []}, {"name": "somaticInformation", "type": ["null",
{"type": "record", "name": "SomaticInformation", "doc": "", "fields": [{"name": "primarySite",
"type": ["null", "string"], "doc": ""}, {"name": "siteSubtype", "type": ["null", "string"], "doc":
""}, {"name": "primaryHistology", "type": ["null", "string"], "doc": ""}, {"name":
"histologySubtype", "type": ["null", "string"], "doc": ""}, {"name": "tumourOrigin", "type":
["null", "string"], "doc": ""}, {"name": "sampleSource", "type": ["null", "string"], "doc": ""}]}],
"doc": ""}, {"name": "url", "type": ["null", "string"], "doc": ""}, {"name": "id", "type": ["null",
"string"], "doc": ""}, {"name": "assembly", "type": ["null", "string"], "doc": ""}, {"name":
"alleleOrigin", "type": ["null", {"type": "array", "items": {"type": "enum", "name": "AlleleOrigin",
"doc": "", "symbols": ["de_novo_variant", "germline_variant", "maternal_variant",
"paternal_variant", "pedigree_specific_variant", "population_specific_variant",
"somatic_variant"]}}], "doc": ""}, {"name": "heritableTraits", "type": {"type": "array", "items":
{"type": "record", "name": "HeritableTrait", "doc": "", "fields": [{"name": "trait", "type":
"string", "doc": ""}, {"name": "inheritanceMode", "type": {"type": "enum", "name":
"ModeOfInheritance", "doc": "", "symbols": ["monoallelic", "monoallelic_not_imprinted",
"monoallelic_maternally_imprinted", "monoallelic_paternally_imprinted", "biallelic",
"monoallelic_and_biallelic", "monoallelic_and_more_severe_biallelic", "xlinked_biallelic",
"xlinked_monoallelic", "mitochondrial", "unknown", "NA"]}, "doc": ""}]}}, "doc": "", "default": []},
{"name": "genomicFeatures", "type": {"type": "array", "items": {"type": "record", "name":
"GenomicFeature", "doc": "", "fields": [{"name": "featureType", "type": {"type": "enum", "name":
"FeatureTypes", "doc": "", "symbols": ["RegulatoryRegion", "Gene", "Transcript", "Protein"]}, "doc":
""}, {"name": "ensemblId", "type": ["null", "string"], "doc": ""}, {"name": "xrefs", "type":
["null", {"type": "map", "values": "string"}], "doc": ""}]}}, "doc": "", "default": []}, {"name":
"variantClassification", "type": ["null", {"type": "record", "name": "VariantClassification", "doc":
"", "fields": [{"name": "clinicalSignificance", "type": ["null", {"type": "enum", "name":
"ClinicalSignificance", "doc": "", "symbols": ["benign", "likely_benign", "VUS",
"likely_pathogenic", "pathogenic", "uncertain_significance"]}], "doc": ""}, {"name":
"drugResponseClassification", "type": ["null", {"type": "enum", "name":
"DrugResponseClassification", "doc": "", "symbols": ["responsive", "resistant", "toxicity",
"indication", "contraindication", "dosing", "increased_monitoring", "efficacy"]}], "doc": ""},
{"name": "traitAssociation", "type": ["null", {"type": "enum", "name": "TraitAssociation", "doc":
"", "symbols": ["established_risk_allele", "likely_risk_allele", "uncertain_risk_allele",
"protective"]}], "doc": ""}, {"name": "tumorigenesisClassification", "type": ["null", {"type":
"enum", "name": "TumorigenesisClassification", "doc": "", "symbols": ["driver", "passenger",
"modifier"]}], "doc": ""}, {"name": "functionalEffect", "type": ["null", {"type": "enum", "name":
"VariantFunctionalEffect", "doc": "", "symbols": ["dominant_negative_variant",
"gain_of_function_variant", "lethal_variant", "loss_of_function_variant", "loss_of_heterozygosity",
"null_variant"]}], "doc": ""}]}], "doc": ""}, {"name": "impact", "type": ["null", {"type": "enum",
"name": "EvidenceImpact", "doc": "", "symbols": ["very_strong", "strong", "moderate", "supporting",
"stand_alone"]}], "doc": ""}, {"name": "confidence", "type": ["null", {"type": "enum", "name":
"Confidence", "doc": "", "symbols": ["low_confidence_level", "medium_confidence_level",
"high_confidence_level", "rejected"]}], "doc": ""}, {"name": "consistencyStatus", "type": ["null",
{"type": "enum", "name": "ConsistencyStatus", "doc": "", "symbols": ["congruent", "conflict",
"weakly_conflicting", "strongly_conflicting"]}], "doc": ""}, {"name": "ethnicity", "type": {"type":
"enum", "name": "EthnicCategory", "doc": "", "symbols": ["D", "E", "F", "G", "A", "B", "C", "L",
"M", "N", "H", "J", "K", "P", "S", "R", "Z"]}, "doc": ""}, {"name": "penetrance", "type": ["null",
{"type": "enum", "name": "Penetrance", "doc": "", "symbols": ["complete", "incomplete"]}], "doc":
""}, {"name": "variableExpressivity", "type": ["null", "boolean"], "doc": ""}, {"name":
"description", "type": ["null", "string"], "doc": ""}, {"name": "additionalProperties", "type":
{"type": "array", "items": {"type": "record", "name": "Property", "doc": "", "fields": [{"name":
"id", "type": ["null", "string"], "doc": ""}, {"name": "name", "type": ["null", "string"], "doc":
""}, {"name": "value", "type": ["null", "string"], "doc": ""}]}}, "doc": "", "default": []},
{"name": "bibliography", "type": {"type": "array", "items": "string"}, "doc": "", "default": []}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "alleleOrigin",
        "assembly",
        "confidence",
        "consistencyStatus",
        "description",
        "ethnicity",
        "id",
        "impact",
        "penetrance",
        "somaticInformation",
        "source",
        "url",
        "variableExpressivity",
        "variantClassification",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'additionalProperties': Property,
            'genomicFeatures': GenomicFeature,
            'heritableTraits': HeritableTrait,
            'somaticInformation': SomaticInformation,
            'source': EvidenceSource,
            'submissions': EvidenceSubmission,
            'variantClassification': VariantClassification,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'additionalProperties': Property,
            'genomicFeatures': GenomicFeature,
            'heritableTraits': HeritableTrait,
            'somaticInformation': SomaticInformation,
            'source': EvidenceSource,
            'submissions': EvidenceSubmission,
            'variantClassification': VariantClassification,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'additionalProperties', 'alleleOrigin', 'assembly',
        'bibliography', 'confidence', 'consistencyStatus',
        'description', 'ethnicity', 'genomicFeatures',
        'heritableTraits', 'id', 'impact', 'penetrance',
        'somaticInformation', 'source', 'submissions', 'url',
        'variableExpressivity', 'variantClassification'
    ]

    def __init__(self, **kwargs):
        self.additionalProperties = kwargs.get(
            'additionalProperties', [])
        self.alleleOrigin = kwargs.get(
            'alleleOrigin', None)
        self.assembly = kwargs.get(
            'assembly', None)
        self.bibliography = kwargs.get(
            'bibliography', [])
        self.confidence = kwargs.get(
            'confidence', None)
        self.consistencyStatus = kwargs.get(
            'consistencyStatus', None)
        self.description = kwargs.get(
            'description', None)
        self.ethnicity = kwargs.get(
            'ethnicity', None)
        self.genomicFeatures = kwargs.get(
            'genomicFeatures', [])
        self.heritableTraits = kwargs.get(
            'heritableTraits', [])
        self.id = kwargs.get(
            'id', None)
        self.impact = kwargs.get(
            'impact', None)
        self.penetrance = kwargs.get(
            'penetrance', None)
        self.somaticInformation = kwargs.get(
            'somaticInformation', None)
        self.source = kwargs.get(
            'source', EvidenceSource())
        self.submissions = kwargs.get(
            'submissions', [])
        self.url = kwargs.get(
            'url', None)
        self.variableExpressivity = kwargs.get(
            'variableExpressivity', None)
        self.variantClassification = kwargs.get(
            'variantClassification', None)


class EvidenceImpact(object):
    """
    Evidence of pathogenicity and benign impact as defined in
    Richards, S. et al. (2015). Standards and guidelines for the
    interpretation     of sequence variants: a joint consensus
    recommendation of the American College of Medical Genetics and
    Genomics and     the Association for Molecular Pathology. Genetics
    in Medicine, 17(5), 405?423. https://doi.org/10.1038/gim.2015.30
    Evidence of pathogenicity: * `very_strong`:     - PVS1 null
    variant (nonsense, frameshift, canonical ?1 or 2 splice sites,
    initiation codon, single or multiexon     deletion) in a gene
    where LOF is a known mechanism of disease * `strong`:     - PS1
    Same amino acid change as a previously established pathogenic
    variant regardless of nucleotide change     - PS2 De novo (both
    maternity and paternity confirmed) in a patient with the disease
    and no family history     - PS3 Well-established in vitro or in
    vivo functional studies supportive of a damaging effect on the
    gene or gene     product     - PS4 The prevalence of the variant
    in affected individuals is significantly increased compared with
    the prevalence     in controls * `moderate`:     - PM1 Located in
    a mutational hot spot and/or critical and well-established
    functional domain (e.g., active site of     an enzyme) without
    benign variation     - PM2 Absent from controls (or at extremely
    low frequency if recessive) in Exome Sequencing Project, 1000
    Genomes     Project, or Exome Aggregation Consortium     - PM3 For
    recessive disorders, detected in trans with a pathogenic variant
    - PM4 Protein length changes as a result of in-frame
    deletions/insertions in a nonrepeat region or stop-loss
    variants     - PM5 Novel missense change at an amino acid residue
    where a different missense change determined to be pathogenic
    has been seen before     - PM6 Assumed de novo, but without
    confirmation of paternity and maternity * `supporting`:     - PP1
    Cosegregation with disease in multiple affected family members in
    a gene definitively known to cause the     disease     - PP2
    Missense variant in a gene that has a low rate of benign missense
    variation and in which missense variants are     a common
    mechanism of disease     - PP3 Multiple lines of computational
    evidence support a deleterious effect on the gene or gene product
    (conservation, evolutionary, splicing impact, etc.)     - PP4
    Patient?s phenotype or family history is highly specific for a
    disease with a single genetic etiology     - PP5 Reputable source
    recently reports variant as pathogenic, but the evidence is not
    available to the laboratory     to perform an independent
    evaluation  Evidence of benign impact: * `stand_alone`:     - BA1
    Allele frequency is >5% in Exome Sequencing Project, 1000 Genomes
    Project, or Exome Aggregation     Consortium * `strong`:     - BS1
    Allele frequency is greater than expected for disorder     - BS2
    Observed in a healthy adult individual for a recessive
    (homozygous), dominant (heterozygous), or X-linked
    (hemizygous) disorder, with full penetrance expected at an early
    age     - BS3 Well-established in vitro or in vivo functional
    studies show no damaging effect on protein function or
    splicing     - BS4 Lack of segregation in affected members of a
    family * `supporting`:     - BP1 Missense variant in a gene for
    which primarily truncating variants are known to cause disease
    - BP2 Observed in trans with a pathogenic variant for a fully
    penetrant dominant gene/disorder or observed in cis     with a
    pathogenic variant in any inheritance pattern     - BP3 In-frame
    deletions/insertions in a repetitive region without a known
    function     - BP4 Multiple lines of computational evidence
    suggest no impact on gene or gene product (conservation,
    evolutionary, splicing impact, etc.)     - BP5 Variant found in a
    case with an alternate molecular basis for disease     - BP6
    Reputable source recently reports variant as benign, but the
    evidence is not available to the laboratory to     perform an
    independent evaluation     - BP7 A synonymous (silent) variant for
    which splicing prediction algorithms predict no impact to the
    splice     consensus sequence nor the creation of a new splice
    site AND the nucleotide is not highly conserved
    """
    very_strong = "very_strong"
    strong = "strong"
    moderate = "moderate"
    supporting = "supporting"
    stand_alone = "stand_alone"

    def __hash__(self):
        return str(self).__hash__()


class EvidenceSource(ProtocolElement):
    """
    The source of an evidence.
    """
    _schemaSource = """
{"type": "record", "name": "EvidenceSource", "namespace": "org.opencb.biodata.models.variant.avro",
"doc": "", "fields": [{"name": "name", "type": ["null", "string"], "doc": ""}, {"name": "version",
"type": ["null", "string"], "doc": ""}, {"name": "date", "type": ["null", "string"], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "date",
        "name",
        "version",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'date', 'name', 'version'
    ]

    def __init__(self, **kwargs):
        self.date = kwargs.get(
            'date', None)
        self.name = kwargs.get(
            'name', None)
        self.version = kwargs.get(
            'version', None)


class EvidenceSubmission(ProtocolElement):
    """
    The submission information
    """
    _schemaSource = """
{"type": "record", "name": "EvidenceSubmission", "namespace":
"org.opencb.biodata.models.variant.avro", "doc": "", "fields": [{"name": "submitter", "type":
["null", "string"], "doc": ""}, {"name": "date", "type": ["null", "string"], "doc": ""}, {"name":
"id", "type": ["null", "string"], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "date",
        "id",
        "submitter",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'date', 'id', 'submitter'
    ]

    def __init__(self, **kwargs):
        self.date = kwargs.get(
            'date', None)
        self.id = kwargs.get(
            'id', None)
        self.submitter = kwargs.get(
            'submitter', None)


class ExonOverlap(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ExonOverlap", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "number", "type": ["null", "string"]}, {"name": "percentage", "type": ["null",
"float"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "number",
        "percentage",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'number', 'percentage'
    ]

    def __init__(self, **kwargs):
        self.number = kwargs.get(
            'number', None)
        self.percentage = kwargs.get(
            'percentage', None)


class Expression(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Expression", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "geneName", "type": ["null", "string"]}, {"name": "transcriptId", "type":
["null", "string"]}, {"name": "experimentalFactor", "type": ["null", "string"]}, {"name":
"factorValue", "type": ["null", "string"]}, {"name": "experimentId", "type": ["null", "string"]},
{"name": "technologyPlatform", "type": ["null", "string"]}, {"name": "expression", "type": ["null",
{"type": "enum", "name": "ExpressionCall", "symbols": ["UP", "DOWN"]}]}, {"name": "pvalue", "type":
["null", "float"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "experimentId",
        "experimentalFactor",
        "expression",
        "factorValue",
        "geneName",
        "pvalue",
        "technologyPlatform",
        "transcriptId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'experimentId', 'experimentalFactor', 'expression',
        'factorValue', 'geneName', 'pvalue', 'technologyPlatform',
        'transcriptId'
    ]

    def __init__(self, **kwargs):
        self.experimentId = kwargs.get(
            'experimentId', None)
        self.experimentalFactor = kwargs.get(
            'experimentalFactor', None)
        self.expression = kwargs.get(
            'expression', None)
        self.factorValue = kwargs.get(
            'factorValue', None)
        self.geneName = kwargs.get(
            'geneName', None)
        self.pvalue = kwargs.get(
            'pvalue', None)
        self.technologyPlatform = kwargs.get(
            'technologyPlatform', None)
        self.transcriptId = kwargs.get(
            'transcriptId', None)


class ExpressionCall(object):
    """
    No documentation
    """
    UP = "UP"
    DOWN = "DOWN"

    def __hash__(self):
        return str(self).__hash__()


class FeatureTypes(object):
    """
    The feature types
    """
    RegulatoryRegion = "RegulatoryRegion"
    Gene = "Gene"
    Transcript = "Transcript"
    Protein = "Protein"

    def __hash__(self):
        return str(self).__hash__()


class FileEntry(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "FileEntry", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "fileId", "type": ["null", "string"], "doc": ""}, {"name": "call", "type":
["null", "string"], "doc": ""}, {"name": "attributes", "type": {"type": "map", "values": "string"},
"doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "attributes",
        "call",
        "fileId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'call', 'fileId'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        self.call = kwargs.get(
            'call', None)
        self.fileId = kwargs.get(
            'fileId', None)


class GeneDrugInteraction(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "GeneDrugInteraction", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "geneName", "type": ["null",
"string"]}, {"name": "drugName", "type": ["null", "string"]}, {"name": "source", "type": ["null",
"string"]}, {"name": "studyType", "type": ["null", "string"]}, {"name": "type", "type": ["null",
"string"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "drugName",
        "geneName",
        "source",
        "studyType",
        "type",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'drugName', 'geneName', 'source', 'studyType', 'type'
    ]

    def __init__(self, **kwargs):
        self.drugName = kwargs.get(
            'drugName', None)
        self.geneName = kwargs.get(
            'geneName', None)
        self.source = kwargs.get(
            'source', None)
        self.studyType = kwargs.get(
            'studyType', None)
        self.type = kwargs.get(
            'type', None)


class GeneTraitAssociation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "GeneTraitAssociation", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "id", "type": "string"}, {"name":
"name", "type": "string"}, {"name": "hpo", "type": ["null", "string"]}, {"name": "score", "type":
["null", "float"]}, {"name": "numberOfPubmeds", "type": ["null", "int"]}, {"name":
"associationTypes", "type": ["null", {"type": "array", "items": "string"}]}, {"name": "sources",
"type": ["null", {"type": "array", "items": "string"}]}, {"name": "source", "type": "string"}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "associationTypes",
        "hpo",
        "id",
        "name",
        "numberOfPubmeds",
        "score",
        "source",
        "sources",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'associationTypes', 'hpo', 'id', 'name', 'numberOfPubmeds',
        'score', 'source', 'sources'
    ]

    def __init__(self, **kwargs):
        self.associationTypes = kwargs.get(
            'associationTypes', None)
        self.hpo = kwargs.get(
            'hpo', None)
        self.id = kwargs.get(
            'id', None)
        self.name = kwargs.get(
            'name', None)
        self.numberOfPubmeds = kwargs.get(
            'numberOfPubmeds', None)
        self.score = kwargs.get(
            'score', None)
        self.source = kwargs.get(
            'source', None)
        self.sources = kwargs.get(
            'sources', None)


class GenomicFeature(ProtocolElement):
    """
    The genomic feature
    """
    _schemaSource = """
{"type": "record", "name": "GenomicFeature", "namespace": "org.opencb.biodata.models.variant.avro",
"doc": "", "fields": [{"name": "featureType", "type": {"type": "enum", "name": "FeatureTypes",
"doc": "", "symbols": ["RegulatoryRegion", "Gene", "Transcript", "Protein"]}, "doc": ""}, {"name":
"ensemblId", "type": ["null", "string"], "doc": ""}, {"name": "xrefs", "type": ["null", {"type":
"map", "values": "string"}], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "ensemblId",
        "featureType",
        "xrefs",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'ensemblId', 'featureType', 'xrefs'
    ]

    def __init__(self, **kwargs):
        self.ensemblId = kwargs.get(
            'ensemblId', None)
        self.featureType = kwargs.get(
            'featureType', None)
        self.xrefs = kwargs.get(
            'xrefs', None)


class Genotype(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Genotype", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "reference", "type": "string"}, {"name": "alternate", "type": "string"},
{"name": "allelesIdx", "type": {"type": "array", "items": "int"}, "default": []}, {"name": "phased",
"type": "boolean"}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "alternate",
        "phased",
        "reference",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'allelesIdx', 'alternate', 'phased', 'reference'
    ]

    def __init__(self, **kwargs):
        self.allelesIdx = kwargs.get(
            'allelesIdx', [])
        self.alternate = kwargs.get(
            'alternate', None)
        self.phased = kwargs.get(
            'phased', None)
        self.reference = kwargs.get(
            'reference', None)


class Gwas(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Gwas", "namespace": "org.opencb.biodata.models.variant.avro", "fields":
[{"name": "snpIdCurrent", "type": "string"}, {"name": "traits", "type": {"type": "array", "items":
"string"}}, {"name": "riskAlleleFrequency", "type": "double"}, {"name": "reportedGenes", "type":
"string"}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "reportedGenes",
        "riskAlleleFrequency",
        "snpIdCurrent",
        "traits",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'reportedGenes', 'riskAlleleFrequency', 'snpIdCurrent',
        'traits'
    ]

    def __init__(self, **kwargs):
        self.reportedGenes = kwargs.get(
            'reportedGenes', None)
        self.riskAlleleFrequency = kwargs.get(
            'riskAlleleFrequency', None)
        self.snpIdCurrent = kwargs.get(
            'snpIdCurrent', None)
        self.traits = kwargs.get(
            'traits', None)


class HeritableTrait(ProtocolElement):
    """
    The entity representing a phenotype and its inheritance pattern.
    """
    _schemaSource = """
{"type": "record", "name": "HeritableTrait", "namespace": "org.opencb.biodata.models.variant.avro",
"doc": "", "fields": [{"name": "trait", "type": "string", "doc": ""}, {"name": "inheritanceMode",
"type": {"type": "enum", "name": "ModeOfInheritance", "doc": "", "symbols": ["monoallelic",
"monoallelic_not_imprinted", "monoallelic_maternally_imprinted", "monoallelic_paternally_imprinted",
"biallelic", "monoallelic_and_biallelic", "monoallelic_and_more_severe_biallelic",
"xlinked_biallelic", "xlinked_monoallelic", "mitochondrial", "unknown", "NA"]}, "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "inheritanceMode",
        "trait",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'inheritanceMode', 'trait'
    ]

    def __init__(self, **kwargs):
        self.inheritanceMode = kwargs.get(
            'inheritanceMode', None)
        self.trait = kwargs.get(
            'trait', None)


class ModeOfInheritance(object):
    """
    An enumeration for the different mode of inheritances:  *
    `monoallelic_not_imprinted`: MONOALLELIC, autosomal or
    pseudoautosomal, not imprinted *
    `monoallelic_maternally_imprinted`: MONOALLELIC, autosomal or
    pseudoautosomal, maternally imprinted (paternal allele expressed)
    * `monoallelic_paternally_imprinted`: MONOALLELIC, autosomal or
    pseudoautosomal, paternally imprinted (maternal allele expressed)
    * `monoallelic`: MONOALLELIC, autosomal or pseudoautosomal,
    imprinted status unknown * `biallelic`: BIALLELIC, autosomal or
    pseudoautosomal * `monoallelic_and_biallelic`: BOTH monoallelic
    and biallelic, autosomal or pseudoautosomal *
    `monoallelic_and_more_severe_biallelic`: BOTH monoallelic and
    biallelic, autosomal or pseudoautosomal (but BIALLELIC mutations
    cause a more SEVERE disease form), autosomal or pseudoautosomal *
    `xlinked_biallelic`: X-LINKED: hemizygous mutation in males,
    biallelic mutations in females * `xlinked_monoallelic`: X linked:
    hemizygous mutation in males, monoallelic mutations in females may
    cause disease (may be less severe, later onset than males) *
    `mitochondrial`: MITOCHONDRIAL * `unknown`: Unknown * `NA`: Not
    applicable
    """
    monoallelic = "monoallelic"
    monoallelic_not_imprinted = "monoallelic_not_imprinted"
    monoallelic_maternally_imprinted = "monoallelic_maternally_imprinted"
    monoallelic_paternally_imprinted = "monoallelic_paternally_imprinted"
    biallelic = "biallelic"
    monoallelic_and_biallelic = "monoallelic_and_biallelic"
    monoallelic_and_more_severe_biallelic = "monoallelic_and_more_severe_biallelic"
    xlinked_biallelic = "xlinked_biallelic"
    xlinked_monoallelic = "xlinked_monoallelic"
    mitochondrial = "mitochondrial"
    unknown = "unknown"
    NA = "NA"

    def __hash__(self):
        return str(self).__hash__()


class Penetrance(object):
    """
    Penetrance assumed in the analysis
    """
    complete = "complete"
    incomplete = "incomplete"

    def __hash__(self):
        return str(self).__hash__()


class PopulationFrequency(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "PopulationFrequency", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "study", "type": "string"}, {"name":
"population", "type": "string"}, {"name": "refAllele", "type": "string"}, {"name": "altAllele",
"type": "string"}, {"name": "refAlleleFreq", "type": "float"}, {"name": "altAlleleFreq", "type":
"float"}, {"name": "refHomGenotypeFreq", "type": ["null", "float"]}, {"name": "hetGenotypeFreq",
"type": ["null", "float"]}, {"name": "altHomGenotypeFreq", "type": ["null", "float"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "altAllele",
        "altAlleleFreq",
        "altHomGenotypeFreq",
        "hetGenotypeFreq",
        "population",
        "refAllele",
        "refAlleleFreq",
        "refHomGenotypeFreq",
        "study",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'altAllele', 'altAlleleFreq', 'altHomGenotypeFreq',
        'hetGenotypeFreq', 'population', 'refAllele', 'refAlleleFreq',
        'refHomGenotypeFreq', 'study'
    ]

    def __init__(self, **kwargs):
        self.altAllele = kwargs.get(
            'altAllele', None)
        self.altAlleleFreq = kwargs.get(
            'altAlleleFreq', None)
        self.altHomGenotypeFreq = kwargs.get(
            'altHomGenotypeFreq', None)
        self.hetGenotypeFreq = kwargs.get(
            'hetGenotypeFreq', None)
        self.population = kwargs.get(
            'population', None)
        self.refAllele = kwargs.get(
            'refAllele', None)
        self.refAlleleFreq = kwargs.get(
            'refAlleleFreq', None)
        self.refHomGenotypeFreq = kwargs.get(
            'refHomGenotypeFreq', None)
        self.study = kwargs.get(
            'study', None)


class Property(ProtocolElement):
    """
    A property in the form of name-value pair.     Names are
    restricted to ontology ids, they should be checked against
    existing ontologies in resources like     Ontology Lookup Service.
    """
    _schemaSource = """
{"type": "record", "name": "Property", "namespace": "org.opencb.biodata.models.variant.avro", "doc":
"", "fields": [{"name": "id", "type": ["null", "string"], "doc": ""}, {"name": "name", "type":
["null", "string"], "doc": ""}, {"name": "value", "type": ["null", "string"], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "name",
        "value",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'name', 'value'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        self.name = kwargs.get(
            'name', None)
        self.value = kwargs.get(
            'value', None)


class ProteinFeature(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ProteinFeature", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "id", "type": ["null", "string"]}, {"name": "start", "type": "int"}, {"name":
"end", "type": "int"}, {"name": "type", "type": ["null", "string"]}, {"name": "description", "type":
["null", "string"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "description",
        "end",
        "id",
        "start",
        "type",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'end', 'id', 'start', 'type'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        self.end = kwargs.get(
            'end', None)
        self.id = kwargs.get(
            'id', None)
        self.start = kwargs.get(
            'start', None)
        self.type = kwargs.get(
            'type', None)


class ProteinVariantAnnotation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "ProteinVariantAnnotation", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "uniprotAccession", "type": ["null",
"string"], "default": null}, {"name": "uniprotName", "type": ["null", "string"], "default": null},
{"name": "position", "type": "int"}, {"name": "reference", "type": ["null", "string"]}, {"name":
"alternate", "type": ["null", "string"]}, {"name": "uniprotVariantId", "type": ["null", "string"]},
{"name": "functionalDescription", "type": ["null", "string"]}, {"name": "substitutionScores",
"type": ["null", {"type": "array", "items": {"type": "record", "name": "Score", "fields": [{"name":
"score", "type": "double"}, {"name": "source", "type": "string"}, {"name": "description", "type":
["null", "string"]}]}}]}, {"name": "keywords", "type": ["null", {"type": "array", "items":
"string"}]}, {"name": "features", "type": ["null", {"type": "array", "items": {"type": "record",
"name": "ProteinFeature", "fields": [{"name": "id", "type": ["null", "string"]}, {"name": "start",
"type": "int"}, {"name": "end", "type": "int"}, {"name": "type", "type": ["null", "string"]},
{"name": "description", "type": ["null", "string"]}]}}]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "alternate",
        "features",
        "functionalDescription",
        "keywords",
        "position",
        "reference",
        "substitutionScores",
        "uniprotVariantId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': ProteinFeature,
            'substitutionScores': Score,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': ProteinFeature,
            'substitutionScores': Score,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternate', 'features', 'functionalDescription', 'keywords',
        'position', 'reference', 'substitutionScores',
        'uniprotAccession', 'uniprotName', 'uniprotVariantId'
    ]

    def __init__(self, **kwargs):
        self.alternate = kwargs.get(
            'alternate', None)
        self.features = kwargs.get(
            'features', None)
        self.functionalDescription = kwargs.get(
            'functionalDescription', None)
        self.keywords = kwargs.get(
            'keywords', None)
        self.position = kwargs.get(
            'position', None)
        self.reference = kwargs.get(
            'reference', None)
        self.substitutionScores = kwargs.get(
            'substitutionScores', None)
        self.uniprotAccession = kwargs.get(
            'uniprotAccession', None)
        self.uniprotName = kwargs.get(
            'uniprotName', None)
        self.uniprotVariantId = kwargs.get(
            'uniprotVariantId', None)


class Read(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Read", "namespace": "org.opencb.biodata.models.sequence", "fields":
[{"name": "id", "type": "string", "doc": ""}, {"name": "sequence", "type": "string", "doc": ""},
{"name": "quality", "type": "string", "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "quality",
        "sequence",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'quality', 'sequence'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        self.quality = kwargs.get(
            'quality', None)
        self.sequence = kwargs.get(
            'sequence', None)


class Repeat(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Repeat", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "id", "type": ["null", "string"]}, {"name": "chromosome", "type": ["null",
"string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type": ["null", "int"]},
{"name": "period", "type": ["null", "int"]}, {"name": "copyNumber", "type": ["null", "float"]},
{"name": "percentageMatch", "type": ["null", "float"]}, {"name": "score", "type": ["null",
"float"]}, {"name": "sequence", "type": ["null", "string"]}, {"name": "source", "type": ["null",
"string"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "chromosome",
        "copyNumber",
        "end",
        "id",
        "percentageMatch",
        "period",
        "score",
        "sequence",
        "source",
        "start",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'chromosome', 'copyNumber', 'end', 'id', 'percentageMatch',
        'period', 'score', 'sequence', 'source', 'start'
    ]

    def __init__(self, **kwargs):
        self.chromosome = kwargs.get(
            'chromosome', None)
        self.copyNumber = kwargs.get(
            'copyNumber', None)
        self.end = kwargs.get(
            'end', None)
        self.id = kwargs.get(
            'id', None)
        self.percentageMatch = kwargs.get(
            'percentageMatch', None)
        self.period = kwargs.get(
            'period', None)
        self.score = kwargs.get(
            'score', None)
        self.sequence = kwargs.get(
            'sequence', None)
        self.source = kwargs.get(
            'source', None)
        self.start = kwargs.get(
            'start', None)


class Score(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Score", "namespace": "org.opencb.biodata.models.variant.avro", "fields":
[{"name": "score", "type": "double"}, {"name": "source", "type": "string"}, {"name": "description",
"type": ["null", "string"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "description",
        "score",
        "source",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'score', 'source'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        self.score = kwargs.get(
            'score', None)
        self.source = kwargs.get(
            'source', None)


class SequenceOntologyTerm(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "SequenceOntologyTerm", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "accession", "type": "string"},
{"name": "name", "type": "string"}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "accession",
        "name",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accession', 'name'
    ]

    def __init__(self, **kwargs):
        self.accession = kwargs.get(
            'accession', None)
        self.name = kwargs.get(
            'name', None)


class SomaticInformation(ProtocolElement):
    """
    The somatic information.
    """
    _schemaSource = """
{"type": "record", "name": "SomaticInformation", "namespace":
"org.opencb.biodata.models.variant.avro", "doc": "", "fields": [{"name": "primarySite", "type":
["null", "string"], "doc": ""}, {"name": "siteSubtype", "type": ["null", "string"], "doc": ""},
{"name": "primaryHistology", "type": ["null", "string"], "doc": ""}, {"name": "histologySubtype",
"type": ["null", "string"], "doc": ""}, {"name": "tumourOrigin", "type": ["null", "string"], "doc":
""}, {"name": "sampleSource", "type": ["null", "string"], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "histologySubtype",
        "primaryHistology",
        "primarySite",
        "sampleSource",
        "siteSubtype",
        "tumourOrigin",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'histologySubtype', 'primaryHistology', 'primarySite',
        'sampleSource', 'siteSubtype', 'tumourOrigin'
    ]

    def __init__(self, **kwargs):
        self.histologySubtype = kwargs.get(
            'histologySubtype', None)
        self.primaryHistology = kwargs.get(
            'primaryHistology', None)
        self.primarySite = kwargs.get(
            'primarySite', None)
        self.sampleSource = kwargs.get(
            'sampleSource', None)
        self.siteSubtype = kwargs.get(
            'siteSubtype', None)
        self.tumourOrigin = kwargs.get(
            'tumourOrigin', None)


class StructuralVariantType(object):
    """
    * Type of structural variation      * <ul>      *
    <li>COPY_NUMBER_GAIN for CNVs</li>      * <li>COPY_NUMBER_LOSS for
    CNVs</li>      * <li>TANDEM_DUPLICATION for DUP</li>      * </ul>
    """
    COPY_NUMBER_GAIN = "COPY_NUMBER_GAIN"
    COPY_NUMBER_LOSS = "COPY_NUMBER_LOSS"
    TANDEM_DUPLICATION = "TANDEM_DUPLICATION"

    def __hash__(self):
        return str(self).__hash__()


class StructuralVariation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "StructuralVariation", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "ciStartLeft", "type": ["null",
"int"]}, {"name": "ciStartRight", "type": ["null", "int"]}, {"name": "ciEndLeft", "type": ["null",
"int"]}, {"name": "ciEndRight", "type": ["null", "int"]}, {"name": "copyNumber", "type": ["null",
"int"], "doc": ""}, {"name": "leftSvInsSeq", "type": ["null", "string"], "doc": ""}, {"name":
"rightSvInsSeq", "type": ["null", "string"]}, {"name": "type", "type": ["null", {"type": "enum",
"name": "StructuralVariantType", "doc": "", "symbols": ["COPY_NUMBER_GAIN", "COPY_NUMBER_LOSS",
"TANDEM_DUPLICATION"]}], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "ciEndLeft",
        "ciEndRight",
        "ciStartLeft",
        "ciStartRight",
        "copyNumber",
        "leftSvInsSeq",
        "rightSvInsSeq",
        "type",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'ciEndLeft', 'ciEndRight', 'ciStartLeft', 'ciStartRight',
        'copyNumber', 'leftSvInsSeq', 'rightSvInsSeq', 'type'
    ]

    def __init__(self, **kwargs):
        self.ciEndLeft = kwargs.get(
            'ciEndLeft', None)
        self.ciEndRight = kwargs.get(
            'ciEndRight', None)
        self.ciStartLeft = kwargs.get(
            'ciStartLeft', None)
        self.ciStartRight = kwargs.get(
            'ciStartRight', None)
        self.copyNumber = kwargs.get(
            'copyNumber', None)
        self.leftSvInsSeq = kwargs.get(
            'leftSvInsSeq', None)
        self.rightSvInsSeq = kwargs.get(
            'rightSvInsSeq', None)
        self.type = kwargs.get(
            'type', None)


class StudyEntry(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "StudyEntry", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "studyId", "type": ["null", "string"], "doc": ""}, {"name": "files", "type":
{"type": "array", "items": {"type": "record", "name": "FileEntry", "fields": [{"name": "fileId",
"type": ["null", "string"], "doc": ""}, {"name": "call", "type": ["null", "string"], "doc": ""},
{"name": "attributes", "type": {"type": "map", "values": "string"}, "doc": ""}]}}, "doc": "",
"default": []}, {"name": "secondaryAlternates", "type": ["null", {"type": "array", "items": {"type":
"record", "name": "AlternateCoordinate", "fields": [{"name": "chromosome", "type": ["null",
"string"]}, {"name": "start", "type": ["null", "int"], "doc": ""}, {"name": "end", "type": ["null",
"int"], "doc": ""}, {"name": "reference", "type": ["null", "string"], "doc": ""}, {"name":
"alternate", "type": "string", "doc": ""}, {"name": "type", "type": {"type": "enum", "name":
"VariantType", "doc": "", "symbols": ["SNV", "SNP", "MNV", "MNP", "INDEL", "SV", "INSERTION",
"DELETION", "TRANSLOCATION", "INVERSION", "CNV", "DUPLICATION", "BREAKEND", "NO_VARIATION",
"SYMBOLIC", "MIXED"]}}]}}], "doc": "", "default": null}, {"name": "format", "type": {"type":
"array", "items": "string"}, "doc": ""}, {"name": "samplesData", "type": {"type": "array", "items":
{"type": "array", "items": "string"}}, "doc": ""}, {"name": "stats", "type": {"type": "map",
"values": {"type": "record", "name": "VariantStats", "fields": [{"name": "refAllele", "type":
["null", "string"]}, {"name": "altAllele", "type": ["null", "string"]}, {"name": "refAlleleCount",
"type": ["null", "int"]}, {"name": "altAlleleCount", "type": ["null", "int"]}, {"name":
"genotypesCount", "type": {"type": "map", "values": "int", "java-key-class":
"org.opencb.biodata.models.feature.Genotype"}}, {"name": "genotypesFreq", "type": {"type": "map",
"values": "float", "java-key-class": "org.opencb.biodata.models.feature.Genotype"}}, {"name":
"missingAlleles", "type": ["null", "int"]}, {"name": "missingGenotypes", "type": ["null", "int"]},
{"name": "refAlleleFreq", "type": ["null", "float"]}, {"name": "altAlleleFreq", "type": ["null",
"float"]}, {"name": "maf", "type": ["null", "float"]}, {"name": "mgf", "type": ["null", "float"]},
{"name": "mafAllele", "type": ["null", "string"]}, {"name": "mgfGenotype", "type": ["null",
"string"]}, {"name": "passedFilters", "type": ["null", "boolean"]}, {"name": "mendelianErrors",
"type": ["null", "int"]}, {"name": "casesPercentDominant", "type": ["null", "float"]}, {"name":
"controlsPercentDominant", "type": ["null", "float"]}, {"name": "casesPercentRecessive", "type":
["null", "float"]}, {"name": "controlsPercentRecessive", "type": ["null", "float"]}, {"name":
"quality", "type": ["null", "float"]}, {"name": "numSamples", "type": ["null", "int"]}, {"name":
"variantType", "type": ["null", "VariantType"], "default": null}, {"name": "hw", "type": ["null",
{"type": "record", "name": "VariantHardyWeinbergStats", "fields": [{"name": "chi2", "type": ["null",
"float"]}, {"name": "pValue", "type": ["null", "float"]}, {"name": "n", "type": ["null", "int"]},
{"name": "n_AA_11", "type": ["null", "int"]}, {"name": "n_Aa_10", "type": ["null", "int"]}, {"name":
"n_aa_00", "type": ["null", "int"]}, {"name": "e_AA_11", "type": ["null", "float"]}, {"name":
"e_Aa_10", "type": ["null", "float"]}, {"name": "e_aa_00", "type": ["null", "float"]}, {"name": "p",
"type": ["null", "float"]}, {"name": "q", "type": ["null", "float"]}]}], "default": null}]}}, "doc":
""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "format",
        "samplesData",
        "stats",
        "studyId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'files': FileEntry,
            'secondaryAlternates': AlternateCoordinate,
            'stats': VariantStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'files': FileEntry,
            'secondaryAlternates': AlternateCoordinate,
            'stats': VariantStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'files', 'format', 'samplesData', 'secondaryAlternates',
        'stats', 'studyId'
    ]

    def __init__(self, **kwargs):
        self.files = kwargs.get(
            'files', [])
        self.format = kwargs.get(
            'format', None)
        self.samplesData = kwargs.get(
            'samplesData', None)
        self.secondaryAlternates = kwargs.get(
            'secondaryAlternates', None)
        self.stats = kwargs.get(
            'stats', None)
        self.studyId = kwargs.get(
            'studyId', None)


class Submission(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Submission", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "submitter", "type": "string"}, {"name": "date", "type": ["null", "string"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "date",
        "submitter",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'date', 'submitter'
    ]

    def __init__(self, **kwargs):
        self.date = kwargs.get(
            'date', None)
        self.submitter = kwargs.get(
            'submitter', None)


class TraitAssociation(object):
    """
    Association of variants to a given trait. *
    `established_risk_allele` : Established risk allele for variants
    associated to disease * `likely_risk_allele` : Likely risk allele
    for variants associated to disease * `uncertain_risk_allele` :
    Uncertain risk allele for variants associated to disease *
    `protective` : Protective allele
    """
    established_risk_allele = "established_risk_allele"
    likely_risk_allele = "likely_risk_allele"
    uncertain_risk_allele = "uncertain_risk_allele"
    protective = "protective"

    def __hash__(self):
        return str(self).__hash__()


class TumorigenesisClassification(object):
    """
    Variant classification according to its relation to cancer
    aetiology. * `driver` : Driver variants * `passenger` : Passenger
    variants * `modifier` : Modifier variants
    """
    driver = "driver"
    passenger = "passenger"
    modifier = "modifier"

    def __hash__(self):
        return str(self).__hash__()


class VariantAnnotation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantAnnotation", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "chromosome", "type": ["null",
"string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type": ["null", "int"]},
{"name": "reference", "type": ["null", "string"]}, {"name": "alternate", "type": ["null",
"string"]}, {"name": "ancestralAllele", "type": ["null", "string"]}, {"name": "id", "type": ["null",
"string"]}, {"name": "xrefs", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"Xref", "fields": [{"name": "id", "type": ["null", "string"]}, {"name": "source", "type": ["null",
"string"]}]}}]}, {"name": "hgvs", "type": ["null", {"type": "array", "items": "string"}]}, {"name":
"displayConsequenceType", "type": ["null", "string"]}, {"name": "consequenceTypes", "type": {"type":
"array", "items": {"type": "record", "name": "ConsequenceType", "fields": [{"name": "geneName",
"type": ["null", "string"]}, {"name": "ensemblGeneId", "type": ["null", "string"]}, {"name":
"ensemblTranscriptId", "type": ["null", "string"]}, {"name": "strand", "type": ["null", "string"]},
{"name": "biotype", "type": ["null", "string"]}, {"name": "exonOverlap", "type": ["null", {"type":
"array", "items": {"type": "record", "name": "ExonOverlap", "fields": [{"name": "number", "type":
["null", "string"]}, {"name": "percentage", "type": ["null", "float"]}]}}]}, {"name":
"transcriptAnnotationFlags", "type": ["null", {"type": "array", "items": "string"}]}, {"name":
"cdnaPosition", "type": ["null", "int"]}, {"name": "cdsPosition", "type": ["null", "int"]}, {"name":
"codon", "type": ["null", "string"]}, {"name": "proteinVariantAnnotation", "type": ["null", {"type":
"record", "name": "ProteinVariantAnnotation", "fields": [{"name": "uniprotAccession", "type":
["null", "string"], "default": null}, {"name": "uniprotName", "type": ["null", "string"], "default":
null}, {"name": "position", "type": "int"}, {"name": "reference", "type": ["null", "string"]},
{"name": "alternate", "type": ["null", "string"]}, {"name": "uniprotVariantId", "type": ["null",
"string"]}, {"name": "functionalDescription", "type": ["null", "string"]}, {"name":
"substitutionScores", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"Score", "fields": [{"name": "score", "type": "double"}, {"name": "source", "type": "string"},
{"name": "description", "type": ["null", "string"]}]}}]}, {"name": "keywords", "type": ["null",
{"type": "array", "items": "string"}]}, {"name": "features", "type": ["null", {"type": "array",
"items": {"type": "record", "name": "ProteinFeature", "fields": [{"name": "id", "type": ["null",
"string"]}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "type",
"type": ["null", "string"]}, {"name": "description", "type": ["null", "string"]}]}}]}]}]}, {"name":
"sequenceOntologyTerms", "type": {"type": "array", "items": {"type": "record", "name":
"SequenceOntologyTerm", "fields": [{"name": "accession", "type": "string"}, {"name": "name", "type":
"string"}]}}}]}}, "default": []}, {"name": "populationFrequencies", "type": ["null", {"type":
"array", "items": {"type": "record", "name": "PopulationFrequency", "fields": [{"name": "study",
"type": "string"}, {"name": "population", "type": "string"}, {"name": "refAllele", "type":
"string"}, {"name": "altAllele", "type": "string"}, {"name": "refAlleleFreq", "type": "float"},
{"name": "altAlleleFreq", "type": "float"}, {"name": "refHomGenotypeFreq", "type": ["null",
"float"]}, {"name": "hetGenotypeFreq", "type": ["null", "float"]}, {"name": "altHomGenotypeFreq",
"type": ["null", "float"]}]}}]}, {"name": "minorAllele", "type": ["null", "string"]}, {"name":
"minorAlleleFreq", "type": ["null", "float"]}, {"name": "conservation", "type": ["null", {"type":
"array", "items": "Score"}]}, {"name": "geneExpression", "type": ["null", {"type": "array", "items":
{"type": "record", "name": "Expression", "fields": [{"name": "geneName", "type": ["null",
"string"]}, {"name": "transcriptId", "type": ["null", "string"]}, {"name": "experimentalFactor",
"type": ["null", "string"]}, {"name": "factorValue", "type": ["null", "string"]}, {"name":
"experimentId", "type": ["null", "string"]}, {"name": "technologyPlatform", "type": ["null",
"string"]}, {"name": "expression", "type": ["null", {"type": "enum", "name": "ExpressionCall",
"symbols": ["UP", "DOWN"]}]}, {"name": "pvalue", "type": ["null", "float"]}]}}]}, {"name":
"geneTraitAssociation", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"GeneTraitAssociation", "fields": [{"name": "id", "type": "string"}, {"name": "name", "type":
"string"}, {"name": "hpo", "type": ["null", "string"]}, {"name": "score", "type": ["null",
"float"]}, {"name": "numberOfPubmeds", "type": ["null", "int"]}, {"name": "associationTypes",
"type": ["null", {"type": "array", "items": "string"}]}, {"name": "sources", "type": ["null",
{"type": "array", "items": "string"}]}, {"name": "source", "type": "string"}]}}]}, {"name":
"geneDrugInteraction", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"GeneDrugInteraction", "fields": [{"name": "geneName", "type": ["null", "string"]}, {"name":
"drugName", "type": ["null", "string"]}, {"name": "source", "type": ["null", "string"]}, {"name":
"studyType", "type": ["null", "string"]}, {"name": "type", "type": ["null", "string"]}]}}]},
{"name": "variantTraitAssociation", "type": ["null", {"type": "record", "name":
"VariantTraitAssociation", "fields": [{"name": "clinvar", "type": ["null", {"type": "array",
"items": {"type": "record", "name": "ClinVar", "fields": [{"name": "accession", "type": "string"},
{"name": "clinicalSignificance", "type": "string"}, {"name": "traits", "type": {"type": "array",
"items": "string"}}, {"name": "geneNames", "type": {"type": "array", "items": "string"}}, {"name":
"reviewStatus", "type": "string"}]}}]}, {"name": "gwas", "type": ["null", {"type": "array", "items":
{"type": "record", "name": "Gwas", "fields": [{"name": "snpIdCurrent", "type": "string"}, {"name":
"traits", "type": {"type": "array", "items": "string"}}, {"name": "riskAlleleFrequency", "type":
"double"}, {"name": "reportedGenes", "type": "string"}]}}]}, {"name": "cosmic", "type": ["null",
{"type": "array", "items": {"type": "record", "name": "Cosmic", "fields": [{"name": "mutationId",
"type": "string"}, {"name": "primarySite", "type": "string"}, {"name": "siteSubtype", "type":
"string"}, {"name": "primaryHistology", "type": "string"}, {"name": "histologySubtype", "type":
"string"}, {"name": "sampleSource", "type": "string"}, {"name": "tumourOrigin", "type": "string"},
{"name": "geneName", "type": "string"}, {"name": "mutationSomaticStatus", "type":
"string"}]}}]}]}]}, {"name": "traitAssociation", "type": ["null", {"type": "array", "items":
{"type": "record", "name": "EvidenceEntry", "doc": "", "fields": [{"name": "source", "type":
{"type": "record", "name": "EvidenceSource", "doc": "", "fields": [{"name": "name", "type": ["null",
"string"], "doc": ""}, {"name": "version", "type": ["null", "string"], "doc": ""}, {"name": "date",
"type": ["null", "string"], "doc": ""}]}, "doc": ""}, {"name": "submissions", "type": {"type":
"array", "items": {"type": "record", "name": "EvidenceSubmission", "doc": "", "fields": [{"name":
"submitter", "type": ["null", "string"], "doc": ""}, {"name": "date", "type": ["null", "string"],
"doc": ""}, {"name": "id", "type": ["null", "string"], "doc": ""}]}}, "doc": "", "default": []},
{"name": "somaticInformation", "type": ["null", {"type": "record", "name": "SomaticInformation",
"doc": "", "fields": [{"name": "primarySite", "type": ["null", "string"], "doc": ""}, {"name":
"siteSubtype", "type": ["null", "string"], "doc": ""}, {"name": "primaryHistology", "type": ["null",
"string"], "doc": ""}, {"name": "histologySubtype", "type": ["null", "string"], "doc": ""}, {"name":
"tumourOrigin", "type": ["null", "string"], "doc": ""}, {"name": "sampleSource", "type": ["null",
"string"], "doc": ""}]}], "doc": ""}, {"name": "url", "type": ["null", "string"], "doc": ""},
{"name": "id", "type": ["null", "string"], "doc": ""}, {"name": "assembly", "type": ["null",
"string"], "doc": ""}, {"name": "alleleOrigin", "type": ["null", {"type": "array", "items": {"type":
"enum", "name": "AlleleOrigin", "doc": "", "symbols": ["de_novo_variant", "germline_variant",
"maternal_variant", "paternal_variant", "pedigree_specific_variant", "population_specific_variant",
"somatic_variant"]}}], "doc": ""}, {"name": "heritableTraits", "type": {"type": "array", "items":
{"type": "record", "name": "HeritableTrait", "doc": "", "fields": [{"name": "trait", "type":
"string", "doc": ""}, {"name": "inheritanceMode", "type": {"type": "enum", "name":
"ModeOfInheritance", "doc": "", "symbols": ["monoallelic", "monoallelic_not_imprinted",
"monoallelic_maternally_imprinted", "monoallelic_paternally_imprinted", "biallelic",
"monoallelic_and_biallelic", "monoallelic_and_more_severe_biallelic", "xlinked_biallelic",
"xlinked_monoallelic", "mitochondrial", "unknown", "NA"]}, "doc": ""}]}}, "doc": "", "default": []},
{"name": "genomicFeatures", "type": {"type": "array", "items": {"type": "record", "name":
"GenomicFeature", "doc": "", "fields": [{"name": "featureType", "type": {"type": "enum", "name":
"FeatureTypes", "doc": "", "symbols": ["RegulatoryRegion", "Gene", "Transcript", "Protein"]}, "doc":
""}, {"name": "ensemblId", "type": ["null", "string"], "doc": ""}, {"name": "xrefs", "type":
["null", {"type": "map", "values": "string"}], "doc": ""}]}}, "doc": "", "default": []}, {"name":
"variantClassification", "type": ["null", {"type": "record", "name": "VariantClassification", "doc":
"", "fields": [{"name": "clinicalSignificance", "type": ["null", {"type": "enum", "name":
"ClinicalSignificance", "doc": "", "symbols": ["benign", "likely_benign", "VUS",
"likely_pathogenic", "pathogenic", "uncertain_significance"]}], "doc": ""}, {"name":
"drugResponseClassification", "type": ["null", {"type": "enum", "name":
"DrugResponseClassification", "doc": "", "symbols": ["responsive", "resistant", "toxicity",
"indication", "contraindication", "dosing", "increased_monitoring", "efficacy"]}], "doc": ""},
{"name": "traitAssociation", "type": ["null", {"type": "enum", "name": "TraitAssociation", "doc":
"", "symbols": ["established_risk_allele", "likely_risk_allele", "uncertain_risk_allele",
"protective"]}], "doc": ""}, {"name": "tumorigenesisClassification", "type": ["null", {"type":
"enum", "name": "TumorigenesisClassification", "doc": "", "symbols": ["driver", "passenger",
"modifier"]}], "doc": ""}, {"name": "functionalEffect", "type": ["null", {"type": "enum", "name":
"VariantFunctionalEffect", "doc": "", "symbols": ["dominant_negative_variant",
"gain_of_function_variant", "lethal_variant", "loss_of_function_variant", "loss_of_heterozygosity",
"null_variant"]}], "doc": ""}]}], "doc": ""}, {"name": "impact", "type": ["null", {"type": "enum",
"name": "EvidenceImpact", "doc": "", "symbols": ["very_strong", "strong", "moderate", "supporting",
"stand_alone"]}], "doc": ""}, {"name": "confidence", "type": ["null", {"type": "enum", "name":
"Confidence", "doc": "", "symbols": ["low_confidence_level", "medium_confidence_level",
"high_confidence_level", "rejected"]}], "doc": ""}, {"name": "consistencyStatus", "type": ["null",
{"type": "enum", "name": "ConsistencyStatus", "doc": "", "symbols": ["congruent", "conflict",
"weakly_conflicting", "strongly_conflicting"]}], "doc": ""}, {"name": "ethnicity", "type": {"type":
"enum", "name": "EthnicCategory", "doc": "", "symbols": ["D", "E", "F", "G", "A", "B", "C", "L",
"M", "N", "H", "J", "K", "P", "S", "R", "Z"]}, "doc": ""}, {"name": "penetrance", "type": ["null",
{"type": "enum", "name": "Penetrance", "doc": "", "symbols": ["complete", "incomplete"]}], "doc":
""}, {"name": "variableExpressivity", "type": ["null", "boolean"], "doc": ""}, {"name":
"description", "type": ["null", "string"], "doc": ""}, {"name": "additionalProperties", "type":
{"type": "array", "items": {"type": "record", "name": "Property", "doc": "", "fields": [{"name":
"id", "type": ["null", "string"], "doc": ""}, {"name": "name", "type": ["null", "string"], "doc":
""}, {"name": "value", "type": ["null", "string"], "doc": ""}]}}, "doc": "", "default": []},
{"name": "bibliography", "type": {"type": "array", "items": "string"}, "doc": "", "default":
[]}]}}]}, {"name": "functionalScore", "type": ["null", {"type": "array", "items": "Score"}]},
{"name": "cytoband", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"Cytoband", "fields": [{"name": "stain", "type": ["null", "string"]}, {"name": "name", "type":
["null", "string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type": ["null",
"int"]}]}}]}, {"name": "repeat", "type": ["null", {"type": "array", "items": {"type": "record",
"name": "Repeat", "fields": [{"name": "id", "type": ["null", "string"]}, {"name": "chromosome",
"type": ["null", "string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type":
["null", "int"]}, {"name": "period", "type": ["null", "int"]}, {"name": "copyNumber", "type":
["null", "float"]}, {"name": "percentageMatch", "type": ["null", "float"]}, {"name": "score",
"type": ["null", "float"]}, {"name": "sequence", "type": ["null", "string"]}, {"name": "source",
"type": ["null", "string"]}]}}]}, {"name": "additionalAttributes", "type": ["null", {"type": "map",
"values": {"type": "record", "name": "AdditionalAttribute", "fields": [{"name": "attribute", "type":
{"type": "map", "values": "string"}}]}}], "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "alternate",
        "ancestralAllele",
        "chromosome",
        "conservation",
        "cytoband",
        "displayConsequenceType",
        "end",
        "functionalScore",
        "geneDrugInteraction",
        "geneExpression",
        "geneTraitAssociation",
        "hgvs",
        "id",
        "minorAllele",
        "minorAlleleFreq",
        "populationFrequencies",
        "reference",
        "repeat",
        "start",
        "traitAssociation",
        "variantTraitAssociation",
        "xrefs",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'additionalAttributes': AdditionalAttribute,
            'consequenceTypes': ConsequenceType,
            'conservation': Score,
            'cytoband': Cytoband,
            'functionalScore': Score,
            'geneDrugInteraction': GeneDrugInteraction,
            'geneExpression': Expression,
            'geneTraitAssociation': GeneTraitAssociation,
            'populationFrequencies': PopulationFrequency,
            'repeat': Repeat,
            'traitAssociation': EvidenceEntry,
            'variantTraitAssociation': VariantTraitAssociation,
            'xrefs': Xref,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'additionalAttributes': AdditionalAttribute,
            'consequenceTypes': ConsequenceType,
            'conservation': Score,
            'cytoband': Cytoband,
            'functionalScore': Score,
            'geneDrugInteraction': GeneDrugInteraction,
            'geneExpression': Expression,
            'geneTraitAssociation': GeneTraitAssociation,
            'populationFrequencies': PopulationFrequency,
            'repeat': Repeat,
            'traitAssociation': EvidenceEntry,
            'variantTraitAssociation': VariantTraitAssociation,
            'xrefs': Xref,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'additionalAttributes', 'alternate', 'ancestralAllele',
        'chromosome', 'consequenceTypes', 'conservation', 'cytoband',
        'displayConsequenceType', 'end', 'functionalScore',
        'geneDrugInteraction', 'geneExpression',
        'geneTraitAssociation', 'hgvs', 'id', 'minorAllele',
        'minorAlleleFreq', 'populationFrequencies', 'reference',
        'repeat', 'start', 'traitAssociation',
        'variantTraitAssociation', 'xrefs'
    ]

    def __init__(self, **kwargs):
        self.additionalAttributes = kwargs.get(
            'additionalAttributes', None)
        self.alternate = kwargs.get(
            'alternate', None)
        self.ancestralAllele = kwargs.get(
            'ancestralAllele', None)
        self.chromosome = kwargs.get(
            'chromosome', None)
        self.consequenceTypes = kwargs.get(
            'consequenceTypes', [])
        self.conservation = kwargs.get(
            'conservation', None)
        self.cytoband = kwargs.get(
            'cytoband', None)
        self.displayConsequenceType = kwargs.get(
            'displayConsequenceType', None)
        self.end = kwargs.get(
            'end', None)
        self.functionalScore = kwargs.get(
            'functionalScore', None)
        self.geneDrugInteraction = kwargs.get(
            'geneDrugInteraction', None)
        self.geneExpression = kwargs.get(
            'geneExpression', None)
        self.geneTraitAssociation = kwargs.get(
            'geneTraitAssociation', None)
        self.hgvs = kwargs.get(
            'hgvs', None)
        self.id = kwargs.get(
            'id', None)
        self.minorAllele = kwargs.get(
            'minorAllele', None)
        self.minorAlleleFreq = kwargs.get(
            'minorAlleleFreq', None)
        self.populationFrequencies = kwargs.get(
            'populationFrequencies', None)
        self.reference = kwargs.get(
            'reference', None)
        self.repeat = kwargs.get(
            'repeat', None)
        self.start = kwargs.get(
            'start', None)
        self.traitAssociation = kwargs.get(
            'traitAssociation', None)
        self.variantTraitAssociation = kwargs.get(
            'variantTraitAssociation', None)
        self.xrefs = kwargs.get(
            'xrefs', None)


class VariantAvro(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantAvro", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "id", "type": ["null", "string"], "doc": ""}, {"name": "names", "type": {"type":
"array", "items": "string"}, "doc": "", "default": []}, {"name": "chromosome", "type": "string",
"doc": ""}, {"name": "start", "type": "int", "doc": ""}, {"name": "end", "type": "int", "doc": ""},
{"name": "reference", "type": "string", "doc": ""}, {"name": "alternate", "type": "string", "doc":
""}, {"name": "strand", "type": ["null", "string"], "doc": "", "default": null}, {"name": "sv",
"type": ["null", {"type": "record", "name": "StructuralVariation", "fields": [{"name":
"ciStartLeft", "type": ["null", "int"]}, {"name": "ciStartRight", "type": ["null", "int"]}, {"name":
"ciEndLeft", "type": ["null", "int"]}, {"name": "ciEndRight", "type": ["null", "int"]}, {"name":
"copyNumber", "type": ["null", "int"], "doc": ""}, {"name": "leftSvInsSeq", "type": ["null",
"string"], "doc": ""}, {"name": "rightSvInsSeq", "type": ["null", "string"]}, {"name": "type",
"type": ["null", {"type": "enum", "name": "StructuralVariantType", "doc": "", "symbols":
["COPY_NUMBER_GAIN", "COPY_NUMBER_LOSS", "TANDEM_DUPLICATION"]}], "doc": ""}]}], "doc": "",
"default": null}, {"name": "length", "type": "int", "doc": ""}, {"name": "type", "type": {"type":
"enum", "name": "VariantType", "doc": "", "symbols": ["SNV", "SNP", "MNV", "MNP", "INDEL", "SV",
"INSERTION", "DELETION", "TRANSLOCATION", "INVERSION", "CNV", "DUPLICATION", "BREAKEND",
"NO_VARIATION", "SYMBOLIC", "MIXED"]}, "doc": ""}, {"name": "hgvs", "type": ["null", {"type": "map",
"values": {"type": "array", "items": "string"}}], "doc": "", "default": null}, {"name": "studies",
"type": {"type": "array", "items": {"type": "record", "name": "StudyEntry", "fields": [{"name":
"studyId", "type": ["null", "string"], "doc": ""}, {"name": "files", "type": {"type": "array",
"items": {"type": "record", "name": "FileEntry", "fields": [{"name": "fileId", "type": ["null",
"string"], "doc": ""}, {"name": "call", "type": ["null", "string"], "doc": ""}, {"name":
"attributes", "type": {"type": "map", "values": "string"}, "doc": ""}]}}, "doc": "", "default": []},
{"name": "secondaryAlternates", "type": ["null", {"type": "array", "items": {"type": "record",
"name": "AlternateCoordinate", "fields": [{"name": "chromosome", "type": ["null", "string"]},
{"name": "start", "type": ["null", "int"], "doc": ""}, {"name": "end", "type": ["null", "int"],
"doc": ""}, {"name": "reference", "type": ["null", "string"], "doc": ""}, {"name": "alternate",
"type": "string", "doc": ""}, {"name": "type", "type": "VariantType"}]}}], "doc": "", "default":
null}, {"name": "format", "type": {"type": "array", "items": "string"}, "doc": ""}, {"name":
"samplesData", "type": {"type": "array", "items": {"type": "array", "items": "string"}}, "doc": ""},
{"name": "stats", "type": {"type": "map", "values": {"type": "record", "name": "VariantStats",
"fields": [{"name": "refAllele", "type": ["null", "string"]}, {"name": "altAllele", "type": ["null",
"string"]}, {"name": "refAlleleCount", "type": ["null", "int"]}, {"name": "altAlleleCount", "type":
["null", "int"]}, {"name": "genotypesCount", "type": {"type": "map", "values": "int",
"java-key-class": "org.opencb.biodata.models.feature.Genotype"}}, {"name": "genotypesFreq", "type":
{"type": "map", "values": "float", "java-key-class": "org.opencb.biodata.models.feature.Genotype"}},
{"name": "missingAlleles", "type": ["null", "int"]}, {"name": "missingGenotypes", "type": ["null",
"int"]}, {"name": "refAlleleFreq", "type": ["null", "float"]}, {"name": "altAlleleFreq", "type":
["null", "float"]}, {"name": "maf", "type": ["null", "float"]}, {"name": "mgf", "type": ["null",
"float"]}, {"name": "mafAllele", "type": ["null", "string"]}, {"name": "mgfGenotype", "type":
["null", "string"]}, {"name": "passedFilters", "type": ["null", "boolean"]}, {"name":
"mendelianErrors", "type": ["null", "int"]}, {"name": "casesPercentDominant", "type": ["null",
"float"]}, {"name": "controlsPercentDominant", "type": ["null", "float"]}, {"name":
"casesPercentRecessive", "type": ["null", "float"]}, {"name": "controlsPercentRecessive", "type":
["null", "float"]}, {"name": "quality", "type": ["null", "float"]}, {"name": "numSamples", "type":
["null", "int"]}, {"name": "variantType", "type": ["null", "VariantType"], "default": null},
{"name": "hw", "type": ["null", {"type": "record", "name": "VariantHardyWeinbergStats", "fields":
[{"name": "chi2", "type": ["null", "float"]}, {"name": "pValue", "type": ["null", "float"]},
{"name": "n", "type": ["null", "int"]}, {"name": "n_AA_11", "type": ["null", "int"]}, {"name":
"n_Aa_10", "type": ["null", "int"]}, {"name": "n_aa_00", "type": ["null", "int"]}, {"name":
"e_AA_11", "type": ["null", "float"]}, {"name": "e_Aa_10", "type": ["null", "float"]}, {"name":
"e_aa_00", "type": ["null", "float"]}, {"name": "p", "type": ["null", "float"]}, {"name": "q",
"type": ["null", "float"]}]}], "default": null}]}}, "doc": ""}]}}, "doc": ""}, {"name":
"annotation", "type": ["null", {"type": "record", "name": "VariantAnnotation", "fields": [{"name":
"chromosome", "type": ["null", "string"]}, {"name": "start", "type": ["null", "int"]}, {"name":
"end", "type": ["null", "int"]}, {"name": "reference", "type": ["null", "string"]}, {"name":
"alternate", "type": ["null", "string"]}, {"name": "ancestralAllele", "type": ["null", "string"]},
{"name": "id", "type": ["null", "string"]}, {"name": "xrefs", "type": ["null", {"type": "array",
"items": {"type": "record", "name": "Xref", "fields": [{"name": "id", "type": ["null", "string"]},
{"name": "source", "type": ["null", "string"]}]}}]}, {"name": "hgvs", "type": ["null", {"type":
"array", "items": "string"}]}, {"name": "displayConsequenceType", "type": ["null", "string"]},
{"name": "consequenceTypes", "type": {"type": "array", "items": {"type": "record", "name":
"ConsequenceType", "fields": [{"name": "geneName", "type": ["null", "string"]}, {"name":
"ensemblGeneId", "type": ["null", "string"]}, {"name": "ensemblTranscriptId", "type": ["null",
"string"]}, {"name": "strand", "type": ["null", "string"]}, {"name": "biotype", "type": ["null",
"string"]}, {"name": "exonOverlap", "type": ["null", {"type": "array", "items": {"type": "record",
"name": "ExonOverlap", "fields": [{"name": "number", "type": ["null", "string"]}, {"name":
"percentage", "type": ["null", "float"]}]}}]}, {"name": "transcriptAnnotationFlags", "type":
["null", {"type": "array", "items": "string"}]}, {"name": "cdnaPosition", "type": ["null", "int"]},
{"name": "cdsPosition", "type": ["null", "int"]}, {"name": "codon", "type": ["null", "string"]},
{"name": "proteinVariantAnnotation", "type": ["null", {"type": "record", "name":
"ProteinVariantAnnotation", "fields": [{"name": "uniprotAccession", "type": ["null", "string"],
"default": null}, {"name": "uniprotName", "type": ["null", "string"], "default": null}, {"name":
"position", "type": "int"}, {"name": "reference", "type": ["null", "string"]}, {"name": "alternate",
"type": ["null", "string"]}, {"name": "uniprotVariantId", "type": ["null", "string"]}, {"name":
"functionalDescription", "type": ["null", "string"]}, {"name": "substitutionScores", "type":
["null", {"type": "array", "items": {"type": "record", "name": "Score", "fields": [{"name": "score",
"type": "double"}, {"name": "source", "type": "string"}, {"name": "description", "type": ["null",
"string"]}]}}]}, {"name": "keywords", "type": ["null", {"type": "array", "items": "string"}]},
{"name": "features", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"ProteinFeature", "fields": [{"name": "id", "type": ["null", "string"]}, {"name": "start", "type":
"int"}, {"name": "end", "type": "int"}, {"name": "type", "type": ["null", "string"]}, {"name":
"description", "type": ["null", "string"]}]}}]}]}]}, {"name": "sequenceOntologyTerms", "type":
{"type": "array", "items": {"type": "record", "name": "SequenceOntologyTerm", "fields": [{"name":
"accession", "type": "string"}, {"name": "name", "type": "string"}]}}}]}}, "default": []}, {"name":
"populationFrequencies", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"PopulationFrequency", "fields": [{"name": "study", "type": "string"}, {"name": "population",
"type": "string"}, {"name": "refAllele", "type": "string"}, {"name": "altAllele", "type": "string"},
{"name": "refAlleleFreq", "type": "float"}, {"name": "altAlleleFreq", "type": "float"}, {"name":
"refHomGenotypeFreq", "type": ["null", "float"]}, {"name": "hetGenotypeFreq", "type": ["null",
"float"]}, {"name": "altHomGenotypeFreq", "type": ["null", "float"]}]}}]}, {"name": "minorAllele",
"type": ["null", "string"]}, {"name": "minorAlleleFreq", "type": ["null", "float"]}, {"name":
"conservation", "type": ["null", {"type": "array", "items": "Score"}]}, {"name": "geneExpression",
"type": ["null", {"type": "array", "items": {"type": "record", "name": "Expression", "fields":
[{"name": "geneName", "type": ["null", "string"]}, {"name": "transcriptId", "type": ["null",
"string"]}, {"name": "experimentalFactor", "type": ["null", "string"]}, {"name": "factorValue",
"type": ["null", "string"]}, {"name": "experimentId", "type": ["null", "string"]}, {"name":
"technologyPlatform", "type": ["null", "string"]}, {"name": "expression", "type": ["null", {"type":
"enum", "name": "ExpressionCall", "symbols": ["UP", "DOWN"]}]}, {"name": "pvalue", "type": ["null",
"float"]}]}}]}, {"name": "geneTraitAssociation", "type": ["null", {"type": "array", "items":
{"type": "record", "name": "GeneTraitAssociation", "fields": [{"name": "id", "type": "string"},
{"name": "name", "type": "string"}, {"name": "hpo", "type": ["null", "string"]}, {"name": "score",
"type": ["null", "float"]}, {"name": "numberOfPubmeds", "type": ["null", "int"]}, {"name":
"associationTypes", "type": ["null", {"type": "array", "items": "string"}]}, {"name": "sources",
"type": ["null", {"type": "array", "items": "string"}]}, {"name": "source", "type": "string"}]}}]},
{"name": "geneDrugInteraction", "type": ["null", {"type": "array", "items": {"type": "record",
"name": "GeneDrugInteraction", "fields": [{"name": "geneName", "type": ["null", "string"]}, {"name":
"drugName", "type": ["null", "string"]}, {"name": "source", "type": ["null", "string"]}, {"name":
"studyType", "type": ["null", "string"]}, {"name": "type", "type": ["null", "string"]}]}}]},
{"name": "variantTraitAssociation", "type": ["null", {"type": "record", "name":
"VariantTraitAssociation", "fields": [{"name": "clinvar", "type": ["null", {"type": "array",
"items": {"type": "record", "name": "ClinVar", "fields": [{"name": "accession", "type": "string"},
{"name": "clinicalSignificance", "type": "string"}, {"name": "traits", "type": {"type": "array",
"items": "string"}}, {"name": "geneNames", "type": {"type": "array", "items": "string"}}, {"name":
"reviewStatus", "type": "string"}]}}]}, {"name": "gwas", "type": ["null", {"type": "array", "items":
{"type": "record", "name": "Gwas", "fields": [{"name": "snpIdCurrent", "type": "string"}, {"name":
"traits", "type": {"type": "array", "items": "string"}}, {"name": "riskAlleleFrequency", "type":
"double"}, {"name": "reportedGenes", "type": "string"}]}}]}, {"name": "cosmic", "type": ["null",
{"type": "array", "items": {"type": "record", "name": "Cosmic", "fields": [{"name": "mutationId",
"type": "string"}, {"name": "primarySite", "type": "string"}, {"name": "siteSubtype", "type":
"string"}, {"name": "primaryHistology", "type": "string"}, {"name": "histologySubtype", "type":
"string"}, {"name": "sampleSource", "type": "string"}, {"name": "tumourOrigin", "type": "string"},
{"name": "geneName", "type": "string"}, {"name": "mutationSomaticStatus", "type":
"string"}]}}]}]}]}, {"name": "traitAssociation", "type": ["null", {"type": "array", "items":
{"type": "record", "name": "EvidenceEntry", "doc": "", "fields": [{"name": "source", "type":
{"type": "record", "name": "EvidenceSource", "doc": "", "fields": [{"name": "name", "type": ["null",
"string"], "doc": ""}, {"name": "version", "type": ["null", "string"], "doc": ""}, {"name": "date",
"type": ["null", "string"], "doc": ""}]}, "doc": ""}, {"name": "submissions", "type": {"type":
"array", "items": {"type": "record", "name": "EvidenceSubmission", "doc": "", "fields": [{"name":
"submitter", "type": ["null", "string"], "doc": ""}, {"name": "date", "type": ["null", "string"],
"doc": ""}, {"name": "id", "type": ["null", "string"], "doc": ""}]}}, "doc": "", "default": []},
{"name": "somaticInformation", "type": ["null", {"type": "record", "name": "SomaticInformation",
"doc": "", "fields": [{"name": "primarySite", "type": ["null", "string"], "doc": ""}, {"name":
"siteSubtype", "type": ["null", "string"], "doc": ""}, {"name": "primaryHistology", "type": ["null",
"string"], "doc": ""}, {"name": "histologySubtype", "type": ["null", "string"], "doc": ""}, {"name":
"tumourOrigin", "type": ["null", "string"], "doc": ""}, {"name": "sampleSource", "type": ["null",
"string"], "doc": ""}]}], "doc": ""}, {"name": "url", "type": ["null", "string"], "doc": ""},
{"name": "id", "type": ["null", "string"], "doc": ""}, {"name": "assembly", "type": ["null",
"string"], "doc": ""}, {"name": "alleleOrigin", "type": ["null", {"type": "array", "items": {"type":
"enum", "name": "AlleleOrigin", "doc": "", "symbols": ["de_novo_variant", "germline_variant",
"maternal_variant", "paternal_variant", "pedigree_specific_variant", "population_specific_variant",
"somatic_variant"]}}], "doc": ""}, {"name": "heritableTraits", "type": {"type": "array", "items":
{"type": "record", "name": "HeritableTrait", "doc": "", "fields": [{"name": "trait", "type":
"string", "doc": ""}, {"name": "inheritanceMode", "type": {"type": "enum", "name":
"ModeOfInheritance", "doc": "", "symbols": ["monoallelic", "monoallelic_not_imprinted",
"monoallelic_maternally_imprinted", "monoallelic_paternally_imprinted", "biallelic",
"monoallelic_and_biallelic", "monoallelic_and_more_severe_biallelic", "xlinked_biallelic",
"xlinked_monoallelic", "mitochondrial", "unknown", "NA"]}, "doc": ""}]}}, "doc": "", "default": []},
{"name": "genomicFeatures", "type": {"type": "array", "items": {"type": "record", "name":
"GenomicFeature", "doc": "", "fields": [{"name": "featureType", "type": {"type": "enum", "name":
"FeatureTypes", "doc": "", "symbols": ["RegulatoryRegion", "Gene", "Transcript", "Protein"]}, "doc":
""}, {"name": "ensemblId", "type": ["null", "string"], "doc": ""}, {"name": "xrefs", "type":
["null", {"type": "map", "values": "string"}], "doc": ""}]}}, "doc": "", "default": []}, {"name":
"variantClassification", "type": ["null", {"type": "record", "name": "VariantClassification", "doc":
"", "fields": [{"name": "clinicalSignificance", "type": ["null", {"type": "enum", "name":
"ClinicalSignificance", "doc": "", "symbols": ["benign", "likely_benign", "VUS",
"likely_pathogenic", "pathogenic", "uncertain_significance"]}], "doc": ""}, {"name":
"drugResponseClassification", "type": ["null", {"type": "enum", "name":
"DrugResponseClassification", "doc": "", "symbols": ["responsive", "resistant", "toxicity",
"indication", "contraindication", "dosing", "increased_monitoring", "efficacy"]}], "doc": ""},
{"name": "traitAssociation", "type": ["null", {"type": "enum", "name": "TraitAssociation", "doc":
"", "symbols": ["established_risk_allele", "likely_risk_allele", "uncertain_risk_allele",
"protective"]}], "doc": ""}, {"name": "tumorigenesisClassification", "type": ["null", {"type":
"enum", "name": "TumorigenesisClassification", "doc": "", "symbols": ["driver", "passenger",
"modifier"]}], "doc": ""}, {"name": "functionalEffect", "type": ["null", {"type": "enum", "name":
"VariantFunctionalEffect", "doc": "", "symbols": ["dominant_negative_variant",
"gain_of_function_variant", "lethal_variant", "loss_of_function_variant", "loss_of_heterozygosity",
"null_variant"]}], "doc": ""}]}], "doc": ""}, {"name": "impact", "type": ["null", {"type": "enum",
"name": "EvidenceImpact", "doc": "", "symbols": ["very_strong", "strong", "moderate", "supporting",
"stand_alone"]}], "doc": ""}, {"name": "confidence", "type": ["null", {"type": "enum", "name":
"Confidence", "doc": "", "symbols": ["low_confidence_level", "medium_confidence_level",
"high_confidence_level", "rejected"]}], "doc": ""}, {"name": "consistencyStatus", "type": ["null",
{"type": "enum", "name": "ConsistencyStatus", "doc": "", "symbols": ["congruent", "conflict",
"weakly_conflicting", "strongly_conflicting"]}], "doc": ""}, {"name": "ethnicity", "type": {"type":
"enum", "name": "EthnicCategory", "doc": "", "symbols": ["D", "E", "F", "G", "A", "B", "C", "L",
"M", "N", "H", "J", "K", "P", "S", "R", "Z"]}, "doc": ""}, {"name": "penetrance", "type": ["null",
{"type": "enum", "name": "Penetrance", "doc": "", "symbols": ["complete", "incomplete"]}], "doc":
""}, {"name": "variableExpressivity", "type": ["null", "boolean"], "doc": ""}, {"name":
"description", "type": ["null", "string"], "doc": ""}, {"name": "additionalProperties", "type":
{"type": "array", "items": {"type": "record", "name": "Property", "doc": "", "fields": [{"name":
"id", "type": ["null", "string"], "doc": ""}, {"name": "name", "type": ["null", "string"], "doc":
""}, {"name": "value", "type": ["null", "string"], "doc": ""}]}}, "doc": "", "default": []},
{"name": "bibliography", "type": {"type": "array", "items": "string"}, "doc": "", "default":
[]}]}}]}, {"name": "functionalScore", "type": ["null", {"type": "array", "items": "Score"}]},
{"name": "cytoband", "type": ["null", {"type": "array", "items": {"type": "record", "name":
"Cytoband", "fields": [{"name": "stain", "type": ["null", "string"]}, {"name": "name", "type":
["null", "string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type": ["null",
"int"]}]}}]}, {"name": "repeat", "type": ["null", {"type": "array", "items": {"type": "record",
"name": "Repeat", "fields": [{"name": "id", "type": ["null", "string"]}, {"name": "chromosome",
"type": ["null", "string"]}, {"name": "start", "type": ["null", "int"]}, {"name": "end", "type":
["null", "int"]}, {"name": "period", "type": ["null", "int"]}, {"name": "copyNumber", "type":
["null", "float"]}, {"name": "percentageMatch", "type": ["null", "float"]}, {"name": "score",
"type": ["null", "float"]}, {"name": "sequence", "type": ["null", "string"]}, {"name": "source",
"type": ["null", "string"]}]}}]}, {"name": "additionalAttributes", "type": ["null", {"type": "map",
"values": {"type": "record", "name": "AdditionalAttribute", "fields": [{"name": "attribute", "type":
{"type": "map", "values": "string"}}]}}], "default": null}]}], "doc": "", "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "alternate",
        "chromosome",
        "end",
        "id",
        "length",
        "reference",
        "start",
        "studies",
        "type",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'annotation': VariantAnnotation,
            'studies': StudyEntry,
            'sv': StructuralVariation,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'annotation': VariantAnnotation,
            'studies': StudyEntry,
            'sv': StructuralVariation,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternate', 'annotation', 'chromosome', 'end', 'hgvs', 'id',
        'length', 'names', 'reference', 'start', 'strand', 'studies',
        'sv', 'type'
    ]

    def __init__(self, **kwargs):
        self.alternate = kwargs.get(
            'alternate', None)
        self.annotation = kwargs.get(
            'annotation', None)
        self.chromosome = kwargs.get(
            'chromosome', None)
        self.end = kwargs.get(
            'end', None)
        self.hgvs = kwargs.get(
            'hgvs', None)
        self.id = kwargs.get(
            'id', None)
        self.length = kwargs.get(
            'length', None)
        self.names = kwargs.get(
            'names', [])
        self.reference = kwargs.get(
            'reference', None)
        self.start = kwargs.get(
            'start', None)
        self.strand = kwargs.get(
            'strand', None)
        self.studies = kwargs.get(
            'studies', None)
        self.sv = kwargs.get(
            'sv', None)
        self.type = kwargs.get(
            'type', None)


class VariantClassification(ProtocolElement):
    """
    The variant classification according to different properties.
    """
    _schemaSource = """
{"type": "record", "name": "VariantClassification", "namespace":
"org.opencb.biodata.models.variant.avro", "doc": "", "fields": [{"name": "clinicalSignificance",
"type": ["null", {"type": "enum", "name": "ClinicalSignificance", "doc": "", "symbols": ["benign",
"likely_benign", "VUS", "likely_pathogenic", "pathogenic", "uncertain_significance"]}], "doc": ""},
{"name": "drugResponseClassification", "type": ["null", {"type": "enum", "name":
"DrugResponseClassification", "doc": "", "symbols": ["responsive", "resistant", "toxicity",
"indication", "contraindication", "dosing", "increased_monitoring", "efficacy"]}], "doc": ""},
{"name": "traitAssociation", "type": ["null", {"type": "enum", "name": "TraitAssociation", "doc":
"", "symbols": ["established_risk_allele", "likely_risk_allele", "uncertain_risk_allele",
"protective"]}], "doc": ""}, {"name": "tumorigenesisClassification", "type": ["null", {"type":
"enum", "name": "TumorigenesisClassification", "doc": "", "symbols": ["driver", "passenger",
"modifier"]}], "doc": ""}, {"name": "functionalEffect", "type": ["null", {"type": "enum", "name":
"VariantFunctionalEffect", "doc": "", "symbols": ["dominant_negative_variant",
"gain_of_function_variant", "lethal_variant", "loss_of_function_variant", "loss_of_heterozygosity",
"null_variant"]}], "doc": ""}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "clinicalSignificance",
        "drugResponseClassification",
        "functionalEffect",
        "traitAssociation",
        "tumorigenesisClassification",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'clinicalSignificance', 'drugResponseClassification',
        'functionalEffect', 'traitAssociation',
        'tumorigenesisClassification'
    ]

    def __init__(self, **kwargs):
        self.clinicalSignificance = kwargs.get(
            'clinicalSignificance', None)
        self.drugResponseClassification = kwargs.get(
            'drugResponseClassification', None)
        self.functionalEffect = kwargs.get(
            'functionalEffect', None)
        self.traitAssociation = kwargs.get(
            'traitAssociation', None)
        self.tumorigenesisClassification = kwargs.get(
            'tumorigenesisClassification', None)


class VariantFileMetadata(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantFileMetadata", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "fileId", "type": "string"}, {"name":
"studyId", "type": "string"}, {"name": "fileName", "type": ["null", "string"], "default": null},
{"name": "studyName", "type": ["null", "string"], "default": null}, {"name": "samples", "type":
{"type": "array", "items": "string"}, "default": []}, {"name": "aggregation", "type": {"type":
"enum", "name": "Aggregation", "symbols": ["NONE", "BASIC", "EVS", "EXAC"]}}, {"name": "stats",
"type": ["null", {"type": "record", "name": "VariantGlobalStats", "fields": [{"name": "numRecords",
"type": "int"}, {"name": "samplesCount", "type": "int"}, {"name": "passCount", "type": "int"},
{"name": "transitionsCount", "type": "int"}, {"name": "transversionsCount", "type": "int"}, {"name":
"meanQuality", "type": "double"}, {"name": "variantTypeCounts", "type": {"type": "map", "values":
"int"}}, {"name": "chromosomeCounts", "type": {"type": "map", "values": "int"}}, {"name":
"consequenceTypesCount", "type": {"type": "map", "values": "int"}}]}]}, {"name": "metadata", "type":
{"type": "map", "values": ["string", {"type": "record", "name": "VcfHeader", "fields": [{"name":
"fileFormat", "type": "string"}, {"name": "meta", "type": {"type": "map", "values": {"type":
"array", "items": ["string", {"type": "map", "values": "string"}]}}}]}]}}, {"name": "header",
"type": ["null", "VcfHeader"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "aggregation",
        "fileId",
        "header",
        "metadata",
        "stats",
        "studyId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'header': VcfHeader,
            'stats': VariantGlobalStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'header': VcfHeader,
            'stats': VariantGlobalStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'aggregation', 'fileId', 'fileName', 'header', 'metadata',
        'samples', 'stats', 'studyId', 'studyName'
    ]

    def __init__(self, **kwargs):
        self.aggregation = kwargs.get(
            'aggregation', None)
        self.fileId = kwargs.get(
            'fileId', None)
        self.fileName = kwargs.get(
            'fileName', None)
        self.header = kwargs.get(
            'header', None)
        self.metadata = kwargs.get(
            'metadata', None)
        self.samples = kwargs.get(
            'samples', [])
        self.stats = kwargs.get(
            'stats', None)
        self.studyId = kwargs.get(
            'studyId', None)
        self.studyName = kwargs.get(
            'studyName', None)


class VariantFunctionalEffect(object):
    """
    Variant effect with Sequence Ontology terms.  * `SO_0002052`:
    dominant_negative_variant
    (http://purl.obolibrary.org/obo/SO_0002052) * `SO_0002053`:
    gain_of_function_variant
    (http://purl.obolibrary.org/obo/SO_0002053) * `SO_0001773`:
    lethal_variant (http://purl.obolibrary.org/obo/SO_0001773) *
    `SO_0002054`: loss_of_function_variant
    (http://purl.obolibrary.org/obo/SO_0002054) * `SO_0001786`:
    loss_of_heterozygosity (http://purl.obolibrary.org/obo/SO_0001786)
    * `SO_0002055`: null_variant
    (http://purl.obolibrary.org/obo/SO_0002055)
    """
    dominant_negative_variant = "dominant_negative_variant"
    gain_of_function_variant = "gain_of_function_variant"
    lethal_variant = "lethal_variant"
    loss_of_function_variant = "loss_of_function_variant"
    loss_of_heterozygosity = "loss_of_heterozygosity"
    null_variant = "null_variant"

    def __hash__(self):
        return str(self).__hash__()


class VariantGlobalStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantGlobalStats", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "numRecords", "type": "int"}, {"name":
"samplesCount", "type": "int"}, {"name": "passCount", "type": "int"}, {"name": "transitionsCount",
"type": "int"}, {"name": "transversionsCount", "type": "int"}, {"name": "meanQuality", "type":
"double"}, {"name": "variantTypeCounts", "type": {"type": "map", "values": "int"}}, {"name":
"chromosomeCounts", "type": {"type": "map", "values": "int"}}, {"name": "consequenceTypesCount",
"type": {"type": "map", "values": "int"}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "chromosomeCounts",
        "consequenceTypesCount",
        "meanQuality",
        "numRecords",
        "passCount",
        "samplesCount",
        "transitionsCount",
        "transversionsCount",
        "variantTypeCounts",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'chromosomeCounts', 'consequenceTypesCount', 'meanQuality',
        'numRecords', 'passCount', 'samplesCount', 'transitionsCount',
        'transversionsCount', 'variantTypeCounts'
    ]

    def __init__(self, **kwargs):
        self.chromosomeCounts = kwargs.get(
            'chromosomeCounts', None)
        self.consequenceTypesCount = kwargs.get(
            'consequenceTypesCount', None)
        self.meanQuality = kwargs.get(
            'meanQuality', None)
        self.numRecords = kwargs.get(
            'numRecords', None)
        self.passCount = kwargs.get(
            'passCount', None)
        self.samplesCount = kwargs.get(
            'samplesCount', None)
        self.transitionsCount = kwargs.get(
            'transitionsCount', None)
        self.transversionsCount = kwargs.get(
            'transversionsCount', None)
        self.variantTypeCounts = kwargs.get(
            'variantTypeCounts', None)


class VariantHardyWeinbergStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantHardyWeinbergStats", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "chi2", "type": ["null", "float"]},
{"name": "pValue", "type": ["null", "float"]}, {"name": "n", "type": ["null", "int"]}, {"name":
"n_AA_11", "type": ["null", "int"]}, {"name": "n_Aa_10", "type": ["null", "int"]}, {"name":
"n_aa_00", "type": ["null", "int"]}, {"name": "e_AA_11", "type": ["null", "float"]}, {"name":
"e_Aa_10", "type": ["null", "float"]}, {"name": "e_aa_00", "type": ["null", "float"]}, {"name": "p",
"type": ["null", "float"]}, {"name": "q", "type": ["null", "float"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "chi2",
        "e_AA_11",
        "e_Aa_10",
        "e_aa_00",
        "n",
        "n_AA_11",
        "n_Aa_10",
        "n_aa_00",
        "p",
        "pValue",
        "q",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'chi2', 'e_AA_11', 'e_Aa_10', 'e_aa_00', 'n', 'n_AA_11',
        'n_Aa_10', 'n_aa_00', 'p', 'pValue', 'q'
    ]

    def __init__(self, **kwargs):
        self.chi2 = kwargs.get(
            'chi2', None)
        self.e_AA_11 = kwargs.get(
            'e_AA_11', None)
        self.e_Aa_10 = kwargs.get(
            'e_Aa_10', None)
        self.e_aa_00 = kwargs.get(
            'e_aa_00', None)
        self.n = kwargs.get(
            'n', None)
        self.n_AA_11 = kwargs.get(
            'n_AA_11', None)
        self.n_Aa_10 = kwargs.get(
            'n_Aa_10', None)
        self.n_aa_00 = kwargs.get(
            'n_aa_00', None)
        self.p = kwargs.get(
            'p', None)
        self.pValue = kwargs.get(
            'pValue', None)
        self.q = kwargs.get(
            'q', None)


class VariantStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantStats", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "refAllele", "type": ["null", "string"]}, {"name": "altAllele", "type": ["null",
"string"]}, {"name": "refAlleleCount", "type": ["null", "int"]}, {"name": "altAlleleCount", "type":
["null", "int"]}, {"name": "genotypesCount", "type": {"type": "map", "values": "int",
"java-key-class": "org.opencb.biodata.models.feature.Genotype"}}, {"name": "genotypesFreq", "type":
{"type": "map", "values": "float", "java-key-class": "org.opencb.biodata.models.feature.Genotype"}},
{"name": "missingAlleles", "type": ["null", "int"]}, {"name": "missingGenotypes", "type": ["null",
"int"]}, {"name": "refAlleleFreq", "type": ["null", "float"]}, {"name": "altAlleleFreq", "type":
["null", "float"]}, {"name": "maf", "type": ["null", "float"]}, {"name": "mgf", "type": ["null",
"float"]}, {"name": "mafAllele", "type": ["null", "string"]}, {"name": "mgfGenotype", "type":
["null", "string"]}, {"name": "passedFilters", "type": ["null", "boolean"]}, {"name":
"mendelianErrors", "type": ["null", "int"]}, {"name": "casesPercentDominant", "type": ["null",
"float"]}, {"name": "controlsPercentDominant", "type": ["null", "float"]}, {"name":
"casesPercentRecessive", "type": ["null", "float"]}, {"name": "controlsPercentRecessive", "type":
["null", "float"]}, {"name": "quality", "type": ["null", "float"]}, {"name": "numSamples", "type":
["null", "int"]}, {"name": "variantType", "type": ["null", {"type": "enum", "name": "VariantType",
"doc": "", "symbols": ["SNV", "SNP", "MNV", "MNP", "INDEL", "SV", "INSERTION", "DELETION",
"TRANSLOCATION", "INVERSION", "CNV", "DUPLICATION", "BREAKEND", "NO_VARIATION", "SYMBOLIC",
"MIXED"]}], "default": null}, {"name": "hw", "type": ["null", {"type": "record", "name":
"VariantHardyWeinbergStats", "fields": [{"name": "chi2", "type": ["null", "float"]}, {"name":
"pValue", "type": ["null", "float"]}, {"name": "n", "type": ["null", "int"]}, {"name": "n_AA_11",
"type": ["null", "int"]}, {"name": "n_Aa_10", "type": ["null", "int"]}, {"name": "n_aa_00", "type":
["null", "int"]}, {"name": "e_AA_11", "type": ["null", "float"]}, {"name": "e_Aa_10", "type":
["null", "float"]}, {"name": "e_aa_00", "type": ["null", "float"]}, {"name": "p", "type": ["null",
"float"]}, {"name": "q", "type": ["null", "float"]}]}], "default": null}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "altAllele",
        "altAlleleCount",
        "altAlleleFreq",
        "casesPercentDominant",
        "casesPercentRecessive",
        "controlsPercentDominant",
        "controlsPercentRecessive",
        "genotypesCount",
        "genotypesFreq",
        "maf",
        "mafAllele",
        "mendelianErrors",
        "mgf",
        "mgfGenotype",
        "missingAlleles",
        "missingGenotypes",
        "numSamples",
        "passedFilters",
        "quality",
        "refAllele",
        "refAlleleCount",
        "refAlleleFreq",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'hw': VariantHardyWeinbergStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'hw': VariantHardyWeinbergStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'altAllele', 'altAlleleCount', 'altAlleleFreq',
        'casesPercentDominant', 'casesPercentRecessive',
        'controlsPercentDominant', 'controlsPercentRecessive',
        'genotypesCount', 'genotypesFreq', 'hw', 'maf', 'mafAllele',
        'mendelianErrors', 'mgf', 'mgfGenotype', 'missingAlleles',
        'missingGenotypes', 'numSamples', 'passedFilters', 'quality',
        'refAllele', 'refAlleleCount', 'refAlleleFreq', 'variantType'
    ]

    def __init__(self, **kwargs):
        self.altAllele = kwargs.get(
            'altAllele', None)
        self.altAlleleCount = kwargs.get(
            'altAlleleCount', None)
        self.altAlleleFreq = kwargs.get(
            'altAlleleFreq', None)
        self.casesPercentDominant = kwargs.get(
            'casesPercentDominant', None)
        self.casesPercentRecessive = kwargs.get(
            'casesPercentRecessive', None)
        self.controlsPercentDominant = kwargs.get(
            'controlsPercentDominant', None)
        self.controlsPercentRecessive = kwargs.get(
            'controlsPercentRecessive', None)
        self.genotypesCount = kwargs.get(
            'genotypesCount', None)
        self.genotypesFreq = kwargs.get(
            'genotypesFreq', None)
        self.hw = kwargs.get(
            'hw', None)
        self.maf = kwargs.get(
            'maf', None)
        self.mafAllele = kwargs.get(
            'mafAllele', None)
        self.mendelianErrors = kwargs.get(
            'mendelianErrors', None)
        self.mgf = kwargs.get(
            'mgf', None)
        self.mgfGenotype = kwargs.get(
            'mgfGenotype', None)
        self.missingAlleles = kwargs.get(
            'missingAlleles', None)
        self.missingGenotypes = kwargs.get(
            'missingGenotypes', None)
        self.numSamples = kwargs.get(
            'numSamples', None)
        self.passedFilters = kwargs.get(
            'passedFilters', None)
        self.quality = kwargs.get(
            'quality', None)
        self.refAllele = kwargs.get(
            'refAllele', None)
        self.refAlleleCount = kwargs.get(
            'refAlleleCount', None)
        self.refAlleleFreq = kwargs.get(
            'refAlleleFreq', None)
        self.variantType = kwargs.get(
            'variantType', None)


class VariantTraitAssociation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VariantTraitAssociation", "namespace":
"org.opencb.biodata.models.variant.avro", "fields": [{"name": "clinvar", "type": ["null", {"type":
"array", "items": {"type": "record", "name": "ClinVar", "fields": [{"name": "accession", "type":
"string"}, {"name": "clinicalSignificance", "type": "string"}, {"name": "traits", "type": {"type":
"array", "items": "string"}}, {"name": "geneNames", "type": {"type": "array", "items": "string"}},
{"name": "reviewStatus", "type": "string"}]}}]}, {"name": "gwas", "type": ["null", {"type": "array",
"items": {"type": "record", "name": "Gwas", "fields": [{"name": "snpIdCurrent", "type": "string"},
{"name": "traits", "type": {"type": "array", "items": "string"}}, {"name": "riskAlleleFrequency",
"type": "double"}, {"name": "reportedGenes", "type": "string"}]}}]}, {"name": "cosmic", "type":
["null", {"type": "array", "items": {"type": "record", "name": "Cosmic", "fields": [{"name":
"mutationId", "type": "string"}, {"name": "primarySite", "type": "string"}, {"name": "siteSubtype",
"type": "string"}, {"name": "primaryHistology", "type": "string"}, {"name": "histologySubtype",
"type": "string"}, {"name": "sampleSource", "type": "string"}, {"name": "tumourOrigin", "type":
"string"}, {"name": "geneName", "type": "string"}, {"name": "mutationSomaticStatus", "type":
"string"}]}}]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "clinvar",
        "cosmic",
        "gwas",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'clinvar': ClinVar,
            'cosmic': Cosmic,
            'gwas': Gwas,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'clinvar': ClinVar,
            'cosmic': Cosmic,
            'gwas': Gwas,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'clinvar', 'cosmic', 'gwas'
    ]

    def __init__(self, **kwargs):
        self.clinvar = kwargs.get(
            'clinvar', None)
        self.cosmic = kwargs.get(
            'cosmic', None)
        self.gwas = kwargs.get(
            'gwas', None)


class VariantType(object):
    """
    * Type of variation, which depends mostly on its length.      *
    <ul>      * <li>SNVs involve a single nucleotide, without changes
    in length</li>      * <li>MNVs involve multiple nucleotides,
    without changes in length</li>      * <li>Indels are insertions or
    deletions of less than SV_THRESHOLD (50) nucleotides</li>      *
    <li>Structural variations are large changes of more than
    SV_THRESHOLD nucleotides</li>      * <li>Copy-number variations
    alter the number of copies of a region</li>      * </ul>
    """
    SNV = "SNV"
    SNP = "SNP"
    MNV = "MNV"
    MNP = "MNP"
    INDEL = "INDEL"
    SV = "SV"
    INSERTION = "INSERTION"
    DELETION = "DELETION"
    TRANSLOCATION = "TRANSLOCATION"
    INVERSION = "INVERSION"
    CNV = "CNV"
    DUPLICATION = "DUPLICATION"
    BREAKEND = "BREAKEND"
    NO_VARIATION = "NO_VARIATION"
    SYMBOLIC = "SYMBOLIC"
    MIXED = "MIXED"

    def __hash__(self):
        return str(self).__hash__()


class VcfHeader(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "VcfHeader", "namespace": "org.opencb.biodata.models.variant.avro",
"fields": [{"name": "fileFormat", "type": "string"}, {"name": "meta", "type": {"type": "map",
"values": {"type": "array", "items": ["string", {"type": "map", "values": "string"}]}}}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "fileFormat",
        "meta",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'fileFormat', 'meta'
    ]

    def __init__(self, **kwargs):
        self.fileFormat = kwargs.get(
            'fileFormat', None)
        self.meta = kwargs.get(
            'meta', None)


class Xref(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"type": "record", "name": "Xref", "namespace": "org.opencb.biodata.models.variant.avro", "fields":
[{"name": "id", "type": ["null", "string"]}, {"name": "source", "type": ["null", "string"]}]}
"""
    schema = avro_parse(_schemaSource)
    requiredFields = {
        "id",
        "source",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'source'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        self.source = kwargs.get(
            'source', None)
